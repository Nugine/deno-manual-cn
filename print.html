<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Deno 手册</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">2.</strong> 入门</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/installation.html"><strong aria-hidden="true">2.1.</strong> 安装</a></li><li class="chapter-item expanded "><a href="getting_started/setup_your_environment.html"><strong aria-hidden="true">2.2.</strong> 设置环境</a></li><li class="chapter-item expanded "><a href="getting_started/first_steps.html"><strong aria-hidden="true">2.3.</strong> 第一步</a></li><li class="chapter-item expanded "><a href="getting_started/command_line_interface.html"><strong aria-hidden="true">2.4.</strong> 命令行界面</a></li><li class="chapter-item expanded "><a href="getting_started/permissions.html"><strong aria-hidden="true">2.5.</strong> 权限</a></li><li class="chapter-item expanded "><a href="getting_started/typescript.html"><strong aria-hidden="true">2.6.</strong> 使用 TypeScript</a></li><li class="chapter-item expanded "><a href="getting_started/webassembly.html"><strong aria-hidden="true">2.7.</strong> 使用 WebAssembly</a></li></ol></li><li class="chapter-item expanded "><a href="runtime.html"><strong aria-hidden="true">3.</strong> 运行时</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="runtime/stability.html"><strong aria-hidden="true">3.1.</strong> 稳定性</a></li><li class="chapter-item expanded "><a href="runtime/program_lifecycle.html"><strong aria-hidden="true">3.2.</strong> 程序生命周期</a></li><li class="chapter-item expanded "><a href="runtime/compiler_apis.html"><strong aria-hidden="true">3.3.</strong> 编译器 API</a></li><li class="chapter-item expanded "><a href="runtime/workers.html"><strong aria-hidden="true">3.4.</strong> Worker</a></li></ol></li><li class="chapter-item expanded "><a href="linking_to_external_code.html"><strong aria-hidden="true">4.</strong> 与外部代码连接</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="linking_to_external_code/reloading_modules.html"><strong aria-hidden="true">4.1.</strong> 重新加载模块</a></li><li class="chapter-item expanded "><a href="linking_to_external_code/integrity_checking.html"><strong aria-hidden="true">4.2.</strong> 完整性检查</a></li><li class="chapter-item expanded "><a href="linking_to_external_code/proxies.html"><strong aria-hidden="true">4.3.</strong> 代理</a></li><li class="chapter-item expanded "><a href="linking_to_external_code/import_maps.html"><strong aria-hidden="true">4.4.</strong> 导入映射</a></li></ol></li><li class="chapter-item expanded "><a href="standard_library.html"><strong aria-hidden="true">5.</strong> 标准库</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.</strong> 测试</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/assertions.html"><strong aria-hidden="true">6.1.</strong> 断言</a></li></ol></li><li class="chapter-item expanded "><a href="tools.html"><strong aria-hidden="true">7.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/debugger.html"><strong aria-hidden="true">7.1.</strong> 调试器</a></li><li class="chapter-item expanded "><a href="tools/script_installer.html"><strong aria-hidden="true">7.2.</strong> 脚本安装器</a></li><li class="chapter-item expanded "><a href="tools/formatter.html"><strong aria-hidden="true">7.3.</strong> 格式化工具</a></li><li class="chapter-item expanded "><a href="tools/bundler.html"><strong aria-hidden="true">7.4.</strong> 打包器</a></li><li class="chapter-item expanded "><a href="tools/documentation_generator.html"><strong aria-hidden="true">7.5.</strong> 文档生成器</a></li><li class="chapter-item expanded "><a href="tools/dependency_inspector.html"><strong aria-hidden="true">7.6.</strong> 依赖检查器</a></li><li class="chapter-item expanded "><a href="tools/linter.html"><strong aria-hidden="true">7.7.</strong> Linter</a></li></ol></li><li class="chapter-item expanded "><a href="embedding_deno.html"><strong aria-hidden="true">8.</strong> 嵌入 Deno</a></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">9.</strong> 贡献</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing/building_from_source.html"><strong aria-hidden="true">9.1.</strong> 从源码构建</a></li><li class="chapter-item expanded "><a href="contributing/development_tools.html"><strong aria-hidden="true">9.2.</strong> 开发工具</a></li><li class="chapter-item expanded "><a href="contributing/style_guide.html"><strong aria-hidden="true">9.3.</strong> 风格指南</a></li><li class="chapter-item expanded "><a href="contributing/architecture.html"><strong aria-hidden="true">9.4.</strong> 架构</a></li></ol></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">10.</strong> 示例</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/unix_cat.html"><strong aria-hidden="true">10.1.</strong> Unix cat</a></li><li class="chapter-item expanded "><a href="examples/file_server.html"><strong aria-hidden="true">10.2.</strong> 文件服务</a></li><li class="chapter-item expanded "><a href="examples/tcp_echo.html"><strong aria-hidden="true">10.3.</strong> TCP echo</a></li><li class="chapter-item expanded "><a href="examples/subprocess.html"><strong aria-hidden="true">10.4.</strong> 创建子进程</a></li><li class="chapter-item expanded "><a href="examples/permissions.html"><strong aria-hidden="true">10.5.</strong> 检查与放弃权限</a></li><li class="chapter-item expanded "><a href="examples/os_signals.html"><strong aria-hidden="true">10.6.</strong> 系统信号</a></li><li class="chapter-item expanded "><a href="examples/file_system_events.html"><strong aria-hidden="true">10.7.</strong> 文件系统事件</a></li><li class="chapter-item expanded "><a href="examples/testing_if_main.html"><strong aria-hidden="true">10.8.</strong> 测试当前文件是否为主程序</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Deno 手册</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#介绍" id="介绍">介绍</a></h1>
<blockquote>
<p><a href="https://github.com/Nugine/deno-manual-cn/" rel="noopener noreferrer" target="_blank" style="display:inline-flex;align-items:center"><span style="margin-right:1em">deno-manual-cn</span><img alt="GitHub stars" src="https://img.shields.io/github/stars/Nugine/deno-manual-cn?style=social"> </a></p>
<p>此版本更新于 2020 年 7 月 24 日 <a href="https://github.com/denoland/deno/tree/a8f74aa381c99e9c3c3d8fdfde02919966a3a824">deno @ a8f74aa</a></p>
</blockquote>
<p>Deno 是一个 JavaScript/TypeScript 的运行时，默认使用安全环境执行代码，有着卓越的开发体验。</p>
<p>Deno 建立在 V8、Rust 和 Tokio 的基础上。</p>
<h2><a class="header" href="#功能亮点" id="功能亮点">功能亮点</a></h2>
<ul>
<li>
<p>默认安全。外部代码没有文件系统、网络、环境的访问权限，除非显式开启。</p>
</li>
<li>
<p>支持开箱即用的 TypeScript 的环境。</p>
</li>
<li>
<p>只分发一个独立的可执行文件 (<code>deno</code>)。</p>
</li>
<li>
<p>有着内建的工具箱，比如一个依赖信息查看器 (<code>deno info</code>) 和一个代码格式化工具 (<code>deno fmt</code>)。</p>
</li>
<li>
<p>有一组经过审计的 <a href="https://github.com/denoland/deno/tree/master/std">标准模块</a>，保证能在 Deno 上工作。</p>
</li>
<li>
<p>脚本代码能被打包为一个单独的 JavaScript 文件。</p>
</li>
</ul>
<h2><a class="header" href="#哲学" id="哲学">哲学</a></h2>
<p>Deno 旨在为现代程序员提供高效、安全的脚本环境。</p>
<p>它将始终作为单个可执行文件分发，并且该可执行文件将能运行任何 Deno 程序。给定一个 Deno 程序的 URL，您应该能够用压缩后不超过 15 MB 的 Deno 可执行文件运行它。</p>
<p>Deno 明确地承担了运行时和包管理器的角色。它使用标准的浏览器兼容协议(URL)来加载模块。</p>
<p>对于过去用 bash 或 python 编写的工具脚本来说，Deno 是一个优秀的替代品。</p>
<h2><a class="header" href="#目标" id="目标">目标</a></h2>
<ul>
<li>
<p>只分发一个独立的可执行文件 (<code>deno</code>)。</p>
</li>
<li>
<p>默认安全。外部代码没有文件系统、网络、环境的访问权限，除非显式开启。</p>
</li>
<li>
<p>浏览器兼容：完全用 JavaScript 编写且不使用全局<code>Deno</code>命名空间(或功能测试)的程序是 Deno 程序的子集，应该能够直接在现代浏览器中运行而无需更改。</p>
</li>
<li>
<p>提供内置工具来提升开发体验，比如单元测试、代码格式化、代码检查。</p>
</li>
<li>
<p>不把 V8 的概念泄露到用户空间。</p>
</li>
<li>
<p>能够高效地提供 HTTP 服务</p>
</li>
</ul>
<h2><a class="header" href="#与-nodejs-的比较" id="与-nodejs-的比较">与 Node.js 的比较</a></h2>
<ul>
<li>
<p>Deno 不使用 <code>npm</code>，而是使用 URL 或文件路径引用模块。</p>
</li>
<li>
<p>Deno 在模块解析算法中不使用 <code>package.json</code>。</p>
</li>
<li>
<p>Deno 中的所有异步操作返回 promise，因此 Deno 提供与 Node 不同的 API。</p>
</li>
<li>
<p>Deno 需要显式指定文件、网络和环境权限。</p>
</li>
<li>
<p>当未捕获的错误发生时，Deno 总是会异常退出。</p>
</li>
<li>
<p>使用 ES 模块，不支持 <code>require()</code>。第三方模块通过 URL 导入。</p>
<pre><code class="language-javascript">import * as log from &quot;https://deno.land/std/log/mod.ts&quot;;
</code></pre>
</li>
</ul>
<h2><a class="header" href="#其他关键行为" id="其他关键行为">其他关键行为</a></h2>
<ul>
<li>
<p>远程代码在第一次运行时获取并缓存，直到代码通过 <code>--reload</code> 选项运行。（所以它在飞机上也能工作）</p>
</li>
<li>
<p>从远程 URL 加载的模块或文件应当是不可变且可缓存的。</p>
</li>
</ul>
<h1><a class="header" href="#入门" id="入门">入门</a></h1>
<p>在本章节，我们将讨论；</p>
<ul>
<li>安装 Deno</li>
<li>设置您的环境</li>
<li>运行一个 <code>Hello World</code> 脚本</li>
<li>编写您自己的脚本</li>
<li>命令行界面</li>
<li>理解权限控制</li>
<li>在 Deno 中使用 TypeScript</li>
<li>在 Deno 中使用 WebAssembly</li>
</ul>
<h2><a class="header" href="#安装" id="安装">安装</a></h2>
<p>Deno 能够在 macOS、Linux 和 Windows 上运行。Deno 是一个单独的可执行文件，它没有额外的依赖。</p>
<h3><a class="header" href="#下载安装" id="下载安装">下载安装</a></h3>
<p><a href="https://github.com/denoland/deno_install">deno_install</a> 提供了方便的脚本，用以下载安装 Deno.</p>
<p>使用 Shell (macOS 和 Linux):</p>
<pre><code class="language-shell">curl -fsSL https://deno.land/x/install/install.sh | sh
</code></pre>
<p>使用 PowerShell (Windows):</p>
<pre><code class="language-shell">iwr https://deno.land/x/install/install.ps1 -useb | iex
</code></pre>
<p>使用 <a href="https://scoop.sh/">Scoop</a> (Windows):</p>
<pre><code class="language-shell">scoop install deno
</code></pre>
<p>使用 <a href="https://chocolatey.org/packages/deno">Chocolatey</a> (Windows):</p>
<pre><code class="language-shell">choco install deno
</code></pre>
<p>使用 <a href="https://formulae.brew.sh/formula/deno">Homebrew</a> (macOS):</p>
<pre><code class="language-shell">brew install deno
</code></pre>
<p>使用 <a href="https://crates.io/crates/deno">Cargo</a> (Windows, macOS, Linux):</p>
<pre><code class="language-shell">cargo install deno
</code></pre>
<p>Deno 也可以手动安装，只需从 <a href="https://github.com/denoland/deno/releases">github.com/denoland/deno/releases</a> 下载一个 zip 文件。它仅包含一个单独的可执行文件。在 macOS 和 Linux 上，您需要为它设置执行权限。</p>
<h3><a class="header" href="#测试安装" id="测试安装">测试安装</a></h3>
<p>运行 <code>deno --version</code>，如果它打印出 Deno 版本，说明安装成功。</p>
<p>运行 <code>deno help</code> 以查看帮助文档。</p>
<p>运行 <code>deno help &lt;subcommand&gt;</code> 以查看子命令的选项。</p>
<p>CLI 的详细指南在 <a href="getting_started/./command_line_interface.html">这里</a>。</p>
<h3><a class="header" href="#升级" id="升级">升级</a></h3>
<p>要升级已安装的版本，运行：</p>
<pre><code class="language-shell">deno upgrade
</code></pre>
<p>这会从 <a href="https://github.com/denoland/deno/releases">github.com/denoland/deno/releases</a> 获取最新的发布版本，然后解压并替换现有的版本。</p>
<p>您也可以用此来安装一个特定的版本：</p>
<pre><code class="language-shell">deno upgrade --version 1.0.1
</code></pre>
<h3><a class="header" href="#从源码构建" id="从源码构建">从源码构建</a></h3>
<p>关于构建步骤的信息请查阅 <a href="getting_started/../contributing.html">贡献</a> 章节。</p>
<h2><a class="header" href="#设置您的环境" id="设置您的环境">设置您的环境</a></h2>
<p>要高效地使用 Deno，您需要设置环境，比如命令行自动补全、环境变量、编辑器或 IDE。</p>
<h3><a class="header" href="#环境变量" id="环境变量">环境变量</a></h3>
<p>这是一些控制 Deno 行为的环境变量：</p>
<p><code>DENO_DIR</code> 默认为 <code>$HOME/.cache/deno</code>，但可以设置为任何路径。这是 Deno 存放生成的代码和缓存的源码的路径。</p>
<p>如果 <code>NO_COLOR</code> 被设置，Deno 将会关闭彩色输出 (<a href="https://no-color.org/">https://no-color.org/</a>)。用户代码可以通过布尔常量 <code>Deno.noColor</code> 测试 <code>NO_COLOR</code> 是否被设置，这不需要环境权限 (<code>--allow-env</code>)。</p>
<h3><a class="header" href="#命令行自动补全" id="命令行自动补全">命令行自动补全</a></h3>
<p>通过 <code>deno completions &lt;shell&gt;</code> 命令可以生成补全脚本。它会输出到 stdout，您应该将它重定向到适当的文件。</p>
<p>Deno 支持的 shell 如下：</p>
<ul>
<li>zsh</li>
<li>bash</li>
<li>fish</li>
<li>powershell</li>
<li>elvish</li>
</ul>
<p>示例 (bash)：</p>
<pre><code class="language-shell">deno completions bash &gt; /usr/local/etc/bash_completion.d/deno.bash
source /usr/local/etc/bash_completion.d/deno.bash
</code></pre>
<p>示例 (zsh):</p>
<pre><code class="language-shell">mkdir ~/.oh-my-zsh/custom/plugins/deno
deno completions zsh &gt; ~/.oh-my-zsh/custom/plugins/deno/_deno
</code></pre>
<p>在此之后，在 <code>~/.zshrc</code> 文件中的 plugins 标签下增加 <code>deno</code> 插件。</p>
<h3><a class="header" href="#编辑器和-ide" id="编辑器和-ide">编辑器和 IDE</a></h3>
<p>Deno 需要用文件后缀名来支持模块导入和 HTTP 导入。目前，大多数编辑器和语言服务器没有原生支持这点，一些编辑器可能会抛出“无法找到文件”的错误，或是“不必要的文件后缀名”错误。</p>
<p>社区已经开发了一些插件用来解决这些问题。</p>
<h4><a class="header" href="#vs-code" id="vs-code">VS Code</a></h4>
<p>目前内测版的 <a href="https://github.com/denoland/vscode_deno">vscode_deno</a> 扩展已经发布到了 <a href="https://marketplace.visualstudio.com/items?itemName=denoland.vscode-deno">Visual Studio Marketplace</a>。如果遇到 bug 欢迎提 issues。</p>
<h4><a class="header" href="#jetbrains-ide" id="jetbrains-ide">JetBrains IDE</a></h4>
<p>JetBrains IDE 通过插件来提供 Deno 支持：<a href="https://plugins.jetbrains.com/plugin/14382-deno">Deno 插件</a></p>
<p>要了解有关设置步骤的更多信息，请在 YouTrack 上阅读 <a href="https://youtrack.jetbrains.com/issue/WEB-41607#focus=streamItem-27-4160152.0-0">这个评论</a>。</p>
<h3><a class="header" href="#vim-和-neovim" id="vim-和-neovim">Vim 和 NeoVim</a></h3>
<p>如果您安装 <a href="https://github.com/neoclide/coc.nvim">CoC</a>（intellisense engine and language server protocol），Vim 对于 Deno/TypeScript 来说非常友好。</p>
<p>当安装完 CoC 后，可以在 Vim 内部运行 <code>:CocInstall coc-deno</code>。你会发现，诸如 <code>gd</code>（转到定义）和 <code>gr</code>（转到/查找引用）之类的东西可以正常工作了。</p>
<h4><a class="header" href="#emacs" id="emacs">Emacs</a></h4>
<p>对于目标为 Deno 的 TypeScript 项目，Emacs 工作得很好，只需使用两个插件：</p>
<ul>
<li>
<p><a href="https://github.com/ananthakumaran/tide">tide</a>：这是在 Emacs 中使用 TypeScript 的典范方法。</p>
</li>
<li>
<p><a href="https://github.com/justjavac/typescript-deno-plugin">typescript-deno-plugin</a>：它被 <a href="https://github.com/denoland/vscode_deno">Deno 官方 VSCode 插件</a> 使用。</p>
</li>
</ul>
<p>首先确保您已经安装了 <code>tide</code>，下一步，按照 <a href="https://github.com/justjavac/typescript-deno-plugin">typescript-deno-plugin</a> 页面的指示，在项目中运行 <code>npm install --save-dev typescript-deno-plugin typescript</code> (<code>npm init -y</code> 是必要的)，并在 <code>tsconfig.json</code> 中添加以下设置，然后准备开发吧！</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;plugins&quot;: [
      {
        &quot;name&quot;: &quot;typescript-deno-plugin&quot;,
        &quot;enable&quot;: true, // default is `true`
        &quot;importmap&quot;: &quot;import_map.json&quot;
      }
    ]
  }
}
</code></pre>
<p>如果您没有在列表中看到您最喜欢的 IDE，或许可以开发一个插件，我们的社区能够帮助您起步：<a href="https://discord.gg/deno">Discord</a></p>
<h2><a class="header" href="#第一步" id="第一步">第一步</a></h2>
<p>这个页面包含一些示例，您可以从中学到 Deno 的基本概念。</p>
<p>我们假设您已经对 JavaScript 有过预先的了解，特别是 <code>async</code>/<code>await</code>。如果您没有了解过 JavaScript，您可能需要先阅读这个指南：<a href="https://developer.mozilla.org/zh-CN/docs/learn/JavaScript">JavaScript</a>.</p>
<h3><a class="header" href="#hello-world" id="hello-world">Hello World</a></h3>
<p>Deno 是一个 JavaScript 和 TypeScript 的运行时，并尝试与浏览器兼容并使用现代的功能 (features)。</p>
<p>由于 Deno 具有浏览器兼容性，<code>Hello World</code> 程序与浏览器里的没有区别。</p>
<pre><code class="language-ts">console.log(&quot;Welcome to Deno 🦕&quot;);
</code></pre>
<p>尝试一下：</p>
<pre><code class="language-shell">deno run https://deno.land/std/examples/welcome.ts
</code></pre>
<h3><a class="header" href="#发出一个-http-请求" id="发出一个-http-请求">发出一个 HTTP 请求</a></h3>
<p>通过 HTTP 请求从服务器获取数据是一件很常见的事。让我们编写一个简单的程序来获取文件并打印到终端。</p>
<p>就像浏览器一样，您可以使用 web 标准的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API"><code>fetch</code></a> API 来发出请求。</p>
<pre><code class="language-typescript">const url = Deno.args[0];
const res = await fetch(url);

const body = new Uint8Array(await res.arrayBuffer());
await Deno.stdout.write(body);
</code></pre>
<p>让我们看看它做了什么：</p>
<ol>
<li>
<p>我们取得了第一个命令行参数，存储到变量 <code>url</code>。</p>
</li>
<li>
<p>我们向指定的地址发出请求，等待响应，然后存储到变量 <code>res</code>。</p>
</li>
<li>
<p>我们把响应体解析为一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>，等待接收完毕，将其转换为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array"><code>Uint8Array</code></a>，最后存储到变量 <code>body</code>。</p>
</li>
<li>
<p>我们把 <code>body</code> 的内容写入标准输出流 <code>stdout</code>。</p>
</li>
</ol>
<p>尝试一下：</p>
<pre><code class="language-shell">deno run https://deno.land/std/examples/curl.ts https://example.com
</code></pre>
<p>这个程序将会返回一个关于网络权限的错误，我们做错了什么？您可能会想起来，Deno 默认用安全环境执行代码。这意味着您需要显式赋予程序权限，允许它进行一些特权操作，比如网络访问。</p>
<p>用正确的权限选项再试一次：</p>
<pre><code class="language-shell">deno run --allow-net=example.com https://deno.land/std/examples/curl.ts https://example.com
</code></pre>
<h3><a class="header" href="#读取一个文件" id="读取一个文件">读取一个文件</a></h3>
<p>Deno 也提供内置的 API，它们都位于全局变量 <code>Deno</code> 中。您可以在此找到相关文档：<a href="https://doc.deno.land/https/github.com/denoland/deno/releases/latest/download/lib.deno.d.ts">doc.deno.land</a>。</p>
<p>文件系统 API 没有 web 标准形式，所以 Deno 提供了内置的 API。</p>
<p>示例：<a href="getting_started/../examples/unix_cat.html">Unix cat</a></p>
<p>在这个程序中，每个命令行参数都是一个文件名，参数对应的文件将被依次打开，打印到标准输出流。</p>
<pre><code class="language-ts">const filenames = Deno.args;
for (const filename of filenames) {
  const file = await Deno.open(filename);
  await Deno.copy(file, Deno.stdout);
  file.close();
}
</code></pre>
<p>除了内核到用户空间再到内核的必要拷贝，这里的 <code>copy()</code> 函数不会产生额外的昂贵操作，从文件中读到的数据会原样写入标准输出流。这反映了 Deno I/O 流的通用设计目标。</p>
<p>尝试一下：</p>
<pre><code class="language-shell">deno run --allow-read https://deno.land/std/examples/cat.ts /etc/passwd
</code></pre>
<h3><a class="header" href="#tcp-服务" id="tcp-服务">TCP 服务</a></h3>
<p>示例：<a href="getting_started/../examples/tcp_echo.html">TCP echo</a></p>
<p>这个示例是一个 TCP echo 服务，接收 8080 端口的连接，把接收到的任何数据返回给客户端。</p>
<pre><code class="language-ts">const hostname = &quot;0.0.0.0&quot;;
const port = 8080;
const listener = Deno.listen({ hostname, port });
console.log(`Listening on ${hostname}:${port}`);
for await (const conn of listener) {
  Deno.copy(conn, conn);
}
</code></pre>
<p>当这个程序启动时，它会抛出一个没有网络权限的错误。</p>
<pre><code class="language-shell">$ deno run https://deno.land/std/examples/echo_server.ts
error: Uncaught PermissionDenied: network access to &quot;0.0.0.0:8080&quot;, run again with the --allow-net flag
► $deno$/dispatch_json.ts:40:11
    at DenoError ($deno$/errors.ts:20:5)
    ...
</code></pre>
<p>为了安全，Deno 不允许程序访问网络，除非显式赋予权限。使用一个命令行选项来允许程序访问网络：</p>
<pre><code class="language-shell">deno run --allow-net https://deno.land/std/examples/echo_server.ts
</code></pre>
<p>尝试用 netcat 向它发送数据。</p>
<pre><code class="language-shell">$ nc localhost 8080
hello world
hello world
</code></pre>
<p>像示例 <code>cat.ts</code> 一样，<code>copy()</code> 函数不会产生不必要的内存拷贝。它从内核接收数据包，然后发送回去，就这么简单。</p>
<h3><a class="header" href="#更多示例" id="更多示例">更多示例</a></h3>
<p>您可以在 <a href="getting_started/../examples.html">示例</a> 一章找到更多示例。</p>
<h2><a class="header" href="#命令行界面" id="命令行界面">命令行界面</a></h2>
<p>Deno 是一个命令行程序。到目前为止，看过这些示例后，您应该熟悉了一些简单的命令，并且已经了解了 shell 的基本用法。</p>
<p>这是查看主要帮助文档的几种方法：</p>
<pre><code class="language-shell"># 使用子命令
deno help

# 使用短选项 —— 输出和上面一样
deno -h

# 使用长选项 —— 输出更加详细
deno --help
</code></pre>
<p>Deno 的 CLI 是基于子命令的。上面的帮助命令应该显示了一个子命令列表，例如 <code>deno bundle</code>。</p>
<p>要查看特定于子命令的帮助，您可以参考以下示例：</p>
<pre><code class="language-shell">deno help bundle
deno bundle -h
deno bundle --help
</code></pre>
<p>各个子命令的详细指南在 <a href="getting_started/../tools.html">这里</a>。</p>
<h3><a class="header" href="#脚本来源" id="脚本来源">脚本来源</a></h3>
<p>Deno 可以从多个来源获取脚本，一个文件名，一个 URL，或者是 &quot;-&quot;，表示从标准输入读取，在与其他应用集成时很有用。</p>
<pre><code class="language-shell">deno run main.ts
deno run https://mydomain.com/main.ts
cat main.ts | deno run -
</code></pre>
<h3><a class="header" href="#脚本参数" id="脚本参数">脚本参数</a></h3>
<p>通过在脚本名称后指定参数，您可以将用户空间参数传递给要运行的脚本，这些参数与 Deno 运行时选项区分开。</p>
<pre><code class="language-shell">deno run main.ts a b -c --quiet
</code></pre>
<pre><code class="language-ts">// main.ts
console.log(Deno.args); // [ &quot;a&quot;, &quot;b&quot;, &quot;-c&quot;, &quot;--quiet&quot; ]
</code></pre>
<p><strong>请注意，在脚本名称之后传递的所有内容都将作为脚本参数传递，而不会用作 Deno 运行时选项。</strong></p>
<p>这将导致以下陷阱：</p>
<pre><code class="language-shell"># 正常情况：我们给 net_client.ts 授予网络权限。
deno run --allow-net net_client.ts

# 错误情况：--allow-net 传递为 Deno.args，引发网络权限错误。
deno run net_client.ts --allow-net
</code></pre>
<p>有人认为这打破了常规：</p>
<blockquote>
<p>一个非位置选项的解析方式会根据位置变化。</p>
</blockquote>
<p>然而：</p>
<ol>
<li>这是区分运行时选项和脚本参数的最合乎逻辑的方法。</li>
<li>这是区分运行时选项和脚本参数的最符合人体工程学的方法。</li>
<li>实际上，这和其他流行的运行时具有相同的行为。
<ul>
<li>试试 <code>node -c index.js</code> 和 <code>node index.js -c</code>，第一个只会根据 <code>-c</code> 选项对 <code>index.js</code> 做语法检查，而第二个会 <em>执行</em> <code>index.js</code>，将 <code>-c</code> 传递为 <code>require(&quot;process&quot;).argv</code>。</li>
</ul>
</li>
</ol>
<hr />
<p>下面是在相关的子命令之间共享的逻辑选项组。</p>
<h3><a class="header" href="#完整性选项" id="完整性选项">完整性选项</a></h3>
<p>影响可以将资源下载到缓存的命令：<code>deno cache</code>，<code>deno run</code> 和 <code>deno test</code>.</p>
<pre><code>--lock &lt;FILE&gt;    检查指定的锁文件
--lock-write     写入锁文件，和 --lock 一起使用
</code></pre>
<p>更多信息在 <a href="getting_started/../linking_to_external_code/integrity_checking.html">这里</a>。</p>
<h3><a class="header" href="#缓存和编译选项" id="缓存和编译选项">缓存和编译选项</a></h3>
<p>影响可以增加缓存的命令：<code>deno cache</code>，<code>deno run</code> 和 <code>deno test</code>. </p>
<p>以及影响模块解析、编译配置等的选项。</p>
<pre><code>--config &lt;FILE&gt;               加载 tsconfig.json 配置文件
--importmap &lt;FILE&gt;            不稳定的: 加载导入映射文件
--no-remote                   不要解析远程模块
--reload=&lt;CACHE_BLOCKLIST&gt;    重新加载源代码缓存（重新编译 TypeScript）
--unstable                    启用不稳定 API
</code></pre>
<h3><a class="header" href="#运行时选项" id="运行时选项">运行时选项</a></h3>
<p>影响可以运行用户代码的命令：<code>deno run</code> 和 <code>deno test</code>.</p>
<h4><a class="header" href="#权限选项" id="权限选项">权限选项</a></h4>
<p><a href="getting_started/./permissions.html#%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8">这里</a> 列出了所有权限选项。</p>
<h4><a class="header" href="#其他运行时选项" id="其他运行时选项">其他运行时选项</a></h4>
<p>影响运行时环境的更多选项：</p>
<pre><code>--cached-only                要求远程依赖已经被缓存
--inspect=&lt;HOST:PORT&gt;        在 host:port 启动检查器
--inspect-brk=&lt;HOST:PORT&gt;    在 host:port 启动检查器并且暂停执行
--seed &lt;NUMBER&gt;              指定 Math.random() 的随机种子
--v8-flags=&lt;v8-flags&gt;        设置 V8 命令行选项
</code></pre>
<h2><a class="header" href="#权限" id="权限">权限</a></h2>
<p>默认情况下，Deno是安全的。因此 Deno 模块没有文件、网络或环境的访问权限，除非您为它授权。在命令行参数中为 deno 进程授权后才能访问安全敏感的功能。</p>
<p>在以下示例中，<code>mod.ts</code> 只被授予文件系统的只读权限。它无法对其进行写入，或执行任何其他对安全性敏感的操作。</p>
<pre><code class="language-shell">deno run --allow-read mod.ts
</code></pre>
<h3><a class="header" href="#权限列表" id="权限列表">权限列表</a></h3>
<p>以下权限是可用的：</p>
<ul>
<li><strong>-A, --allow-all</strong> 允许所有权限，这将禁用所有安全限制。</li>
<li><strong>--allow-env</strong> 允许环境访问，例如读取和设置环境变量。</li>
<li><strong>--allow-hrtime</strong> 允许高精度时间测量，高精度时间能够在计时攻击和特征识别中使用。</li>
<li><strong>--allow-net=&lt;allow-net&gt;</strong> 允许网络访问。您可以指定一系列用逗号分隔的域名，来提供域名白名单。</li>
<li><strong>--allow-plugin</strong> 允许加载插件。请注意：这是一个不稳定功能。</li>
<li><strong>--allow-read=&lt;allow-read&gt;</strong> 允许读取文件系统。您可以指定一系列用逗号分隔的目录或文件，来提供文件系统白名单。</li>
<li><strong>--allow-run</strong> 允许运行子进程。请注意，子进程不在沙箱中运行，因此没有与 deno 进程相同的安全限制，请谨慎使用。</li>
<li><strong>--allow-write=&lt;allow-write&gt;</strong> 允许写入文件系统。您可以指定一系列用逗号分隔的目录或文件，来提供文件系统白名单。</li>
</ul>
<h3><a class="header" href="#权限白名单" id="权限白名单">权限白名单</a></h3>
<p>Deno 还允许您使用白名单控制权限的粒度。</p>
<p>这是一个用白名单限制文件系统访问权限的示例，仅允许访问 <code>/usr</code> 目录，但它会在尝试访问 <code>/etc</code> 目录时失败。</p>
<pre><code class="language-shell">$ deno run --allow-read=/usr https://deno.land/std/examples/cat.ts /etc/passwd
error: Uncaught PermissionDenied: read access to &quot;/etc/passwd&quot;, run again with the --allow-read flag
► $deno$/dispatch_json.ts:40:11
    at DenoError ($deno$/errors.ts:20:5)
    ...
</code></pre>
<p>改为 <code>/etc</code> 目录，赋予正确的权限，再试一次：</p>
<pre><code class="language-shell">deno run --allow-read=/etc https://deno.land/std/examples/cat.ts /etc/passwd
</code></pre>
<p><code>--allow-write</code> 也一样，代表写入权限。</p>
<h3><a class="header" href="#网络访问" id="网络访问">网络访问</a></h3>
<p><em>fetch.ts</em>:</p>
<pre><code class="language-ts">const result = await fetch(&quot;https://deno.land/&quot;);
</code></pre>
<p>这是一个设置 host 或 url 白名单的示例：</p>
<pre><code class="language-shell">deno run --allow-net=github.com,deno.land fetch.ts
</code></pre>
<p>如果 <code>fetch.ts</code> 尝试与其他域名建立网络连接，那么这个进程将会失败。</p>
<p>允许访问任意地址：</p>
<pre><code class="language-shell">deno run --allow-net fetch.ts
</code></pre>
<h2><a class="header" href="#使用-typescript" id="使用-typescript">使用 TypeScript</a></h2>
<!-- TODO(lucacasonato): text on 'just import .ts' -->
<p>Deno 同时支持 JavaScript 和 TypeScript，它们是 Deno 的第一等语言。
这意味着它需要标准的模块名称，包括
扩展名（或提供正确媒体类型的服务器）。此外，Deno 还拥有“平凡”的模块解析算法。导入模块指定为文件（包括扩展名）或全限定 URL (fully qualified URL)。TypeScript 模块可以被直接导入，例如：</p>
<pre><code class="language-ts">import { Response } from &quot;https://deno.land/std@0.53.0/http/server.ts&quot;;
import { queue } from &quot;./collections.ts&quot;;
</code></pre>
<h3><a class="header" href="#--no-check-选项" id="--no-check-选项"><code>--no-check</code> 选项</a></h3>
<p>当使用 <code>deno run</code>、<code>deno test</code>、<code>deno cache</code>、<code>deno info</code> 或 <code>deno bundle</code> 时，您可以指定 <code>--no-check</code> 选项来禁用 TypeScript 的类型检查。这会大大减少程序的启动时间。当您的编辑器提供了类型检查并且您想要程序启动得尽可能快时（比如当文件变化时自动重启），这个选项将非常有用。</p>
<p>由于 <code>--no-check</code> 不执行 TypeScript 类型检查，我们不能自动删除类型导入导出，这需要类型信息。为此 TypeScript 提供了 <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-exports"><code>import type</code> 和 <code>export type</code> 语法</a></p>
<p>从一个不同的文件</p>
<ul>
<li>导出类型：<code>export type { AnInterface } from &quot;./mod.ts&quot;;</code>，</li>
<li>导入类型：<code>import type { AnInterface } from &quot;./mod.ts&quot;;</code></li>
</ul>
<p>您可以通过将 TypeScript 编译选项 <code>importsNotUsedAsValues</code> 设置为 <code>&quot;error&quot;</code> 来检查此类导入导出的必要性。</p>
<p>您可以在标准库中看到这一选项的示例：<a href="https://github.com/denoland/deno/blob/master/std/tsconfig_test.json"><code>tsconfig_test.json</code></a>。</p>
<p>由于使用 <code>--no-check</code> 时没有类型信息，<code>const enum</code> 是不支持的。</p>
<p><code>--no-check</code> 也不支持遗留的 <code>import =</code> 和 <code>export =</code> 语法。</p>
<h3><a class="header" href="#使用外部类型定义" id="使用外部类型定义">使用外部类型定义</a></h3>
<p>开箱即用的 TypeScript 编译器依赖于两种无扩展名
模块和 Node.js 模块解析逻辑，以将类型应用于 JavaScript
模块。</p>
<p>为了弥合这种差距，Deno 支持三种引用类型定义文件的方法，而不必求助于“魔法”的模块解析。</p>
<h4><a class="header" href="#编译提示" id="编译提示">编译提示</a></h4>
<p>如果您要导入 JavaScript 模块，并且知道该模块的类型定义在哪里，您可以在导入时指定类型定义。这采用编译器提示的形式。编译提示告诉 Deno <code>.d.ts</code> 文件的位置和与之相关的导入的 JavaScript 代码。编译提示指令是 <code>@deno-types</code>，当指定时，该值将在编译器中使用，而不是 JavaScript 模块。</p>
<p>例如，如果您有 <code>foo.js</code>，但您知道旁边的 <code>foo.d.ts</code> 是该模块的类型定义，代码将像这样：</p>
<pre><code class="language-ts">// @deno-types=&quot;./foo.d.ts&quot;
import * as foo from &quot;./foo.js&quot;;
</code></pre>
<p>该值遵循与导入模块相同的解析逻辑，这意味着它需要具有扩展名，并且是相对于当前模块的。远程模块也可以使用该说明符。</p>
<p>此编译提示影响下一个 <code>import</code> 语句，或是 <code>export ... from</code> 语句，在编译时，该值将替换模块。像上面的示例一样，Deno 编译器将加载 <code>./foo.d.ts</code>，而不是 <code>./foo.js</code>。Deno 在运行时仍然会加载 <code>./foo.js</code>。</p>
<h4><a class="header" href="#javascript-文件中的三斜杠引用指令" id="javascript-文件中的三斜杠引用指令">JavaScript 文件中的三斜杠引用指令</a></h4>
<p>如果您要发布由 Deno 使用的模块，并且想要告诉 Deno 类型定义的位置，您可以使用实际代码中的三斜杠指令。</p>
<p>例如，如果您有一个 JavaScript 模块，想为 Deno 提供类型定义的位置，您的 <code>foo.js</code> 可能看起来像这样：</p>
<pre><code class="language-js">/// &lt;reference types=&quot;./foo.d.ts&quot; /&gt;
export const foo = &quot;foo&quot;;
</code></pre>
<p>Deno 会看到这一点，并且在检查类型时，编译器将使用 <code>foo.d.ts</code> 文件，尽管 <code>foo.js</code> 将在运行时加载。</p>
<p>该值遵循与导入模块相同的解析逻辑，这意味着它需要具有扩展名，并且是相对于当前模块的。远程模块也可以使用该说明符。</p>
<h4><a class="header" href="#x-typescript-types-自定义-header" id="x-typescript-types-自定义-header">X-TypeScript-Types 自定义 Header</a></h4>
<p>如果您要发布由 Deno 使用的模块，并且想要告诉 Deno 类型定义的位置，您可以使用自定义 HTTP 头 <code>X-TypeScript-Types</code>，来告诉 Deno 文件位置。</p>
<p>标头的工作方式与上述三斜杠参考相同，这只是意味着 JavaScript 文件本身的内容不需要修改后，并且类型定义的位置可以通过服务器本身确定。</p>
<p><strong>不是所有类型定义都受支持</strong></p>
<p>Deno 将使用编译提示来加载指示的 <code>.d.ts</code> 文件，但有些 <code>.d.ts</code> 文件包含不受支持的功能。具体来说，有些 <code>.d.ts</code> 文件期望能够从其他包中加载或引用类型定义，它们使用模块解析逻辑。</p>
<p>例如，一个包含 <code>node</code> 的类型引用指令，希望解析为像 <code>./node_modules/@types/node/index.d.ts</code> 的某些路径。由于这取决于非相对性的模块解析算法，Deno 无法处理这种情况。</p>
<p><strong>为什么不在 TypeScript 文件中使用三斜杠类型引用？</strong></p>
<p>TypeScript 编译器支持三斜杠指令，包括类型
参考指令。如果 Deno 使用此功能，则会干扰
TypeScript 编译器。Deno 仅在 JavaScript （包括 JSX）文件中查找指令。</p>
<h3><a class="header" href="#自定义-typescript-编译器选项" id="自定义-typescript-编译器选项">自定义 TypeScript 编译器选项</a></h3>
<p>在 Deno 生态系统中，所有严格标志都被默认启用，以符合 TypeScript 的理想状态。Deno 也支持自定义配置文件，例如 <code>tsconfig.json</code>。</p>
<p>您需要通过显式设置 <code>-c</code> 或 <code>--config</code> 选项，来明确告诉 Deno 在哪里寻找此配置。</p>
<pre><code class="language-shell">deno run -c tsconfig.json mod.ts
</code></pre>
<p>以下是 Deno 当前允许的设置及其默认值：</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;allowJs&quot;: false,
    &quot;allowUmdGlobalAccess&quot;: false,
    &quot;allowUnreachableCode&quot;: false,
    &quot;allowUnusedLabels&quot;: false,
    &quot;alwaysStrict&quot;: true,
    &quot;assumeChangesOnlyAffectDirectDependencies&quot;: false,
    &quot;checkJs&quot;: false,
    &quot;disableSizeLimit&quot;: false,
    &quot;generateCpuProfile&quot;: &quot;profile.cpuprofile&quot;,
    &quot;jsx&quot;: &quot;react&quot;,
    &quot;jsxFactory&quot;: &quot;React.createElement&quot;,
    &quot;lib&quot;: [],
    &quot;noFallthroughCasesInSwitch&quot;: false,
    &quot;noImplicitAny&quot;: true,
    &quot;noImplicitReturns&quot;: true,
    &quot;noImplicitThis&quot;: true,
    &quot;noImplicitUseStrict&quot;: false,
    &quot;noStrictGenericChecks&quot;: false,
    &quot;noUnusedLocals&quot;: false,
    &quot;noUnusedParameters&quot;: false,
    &quot;preserveConstEnums&quot;: false,
    &quot;removeComments&quot;: false,
    &quot;resolveJsonModule&quot;: true,
    &quot;strict&quot;: true,
    &quot;strictBindCallApply&quot;: true,
    &quot;strictFunctionTypes&quot;: true,
    &quot;strictNullChecks&quot;: true,
    &quot;strictPropertyInitialization&quot;: true,
    &quot;suppressExcessPropertyErrors&quot;: false,
    &quot;suppressImplicitAnyIndexErrors&quot;: false,
    &quot;useDefineForClassFields&quot;: false
  }
}
</code></pre>
<p>有关上述选项和用例的文档，请访问 <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">typescript docs</a>.</p>
<p><strong>注意</strong>：以上列表中不包含 Deno 不支持的选项，或者 TypeScript 文档中已经标记为废弃的/实验性的选项。</p>
<h2><a class="header" href="#webassembly-支持" id="webassembly-支持">WebAssembly 支持</a></h2>
<p>Deno 能够运行 <a href="https://webassembly.org/">WebAssembly</a> 二进制文件。</p>
<!-- dprint-ignore -->
<pre><code class="language-js">const wasmCode = new Uint8Array([
  0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127,
  3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0,
  5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145,
  128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97,
  105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0,
  65, 42, 11
]);
const wasmModule = new WebAssembly.Module(wasmCode);
const wasmInstance = new WebAssembly.Instance(wasmModule);
console.log(wasmInstance.exports.main().toString());
</code></pre>
<h1><a class="header" href="#运行时" id="运行时">运行时</a></h1>
<p>包含所有运行时函数（Web API 与全局空间 <code>Deno</code>）的文档可以在 <a href="https://doc.deno.land/https/github.com/denoland/deno/releases/latest/download/lib.deno.d.ts">doc.deno.land</a> 找到。</p>
<h2><a class="header" href="#web-api" id="web-api">Web API</a></h2>
<p>对于 web 标准中存在的 API，比如 <code>fetch</code>，Deno 使用它们，而不是自己发明新的。</p>
<p>已实现的 Web API 文档：<a href="https://doc.deno.land/https/raw.githubusercontent.com/denoland/deno/master/cli/dts/lib.deno.shared_globals.d.ts">doc.deno.land</a></p>
<p>已实现的 Web API 的列表在 <a href="https://github.com/denoland/deno/blob/master/cli/rt/README.md">这里</a>。</p>
<p>已实现的 web API 的 TypeScript 定义：</p>
<ul>
<li>
<p><a href="https://github.com/denoland/deno/blob/master/cli/dts/lib.deno.shared_globals.d.ts">lib.deno.shared_globals.d.ts</a></p>
</li>
<li>
<p><a href="https://github.com/denoland/deno/blob/master/cli/dts/lib.deno.window.d.ts">lib.deno.window.d.ts</a></p>
</li>
</ul>
<p>worker 特定的 API 定义：<a href="https://github.com/denoland/deno/blob/master/cli/dts/lib.deno.worker.d.ts">lib.deno.worker.d.ts</a></p>
<h2><a class="header" href="#全局空间-deno" id="全局空间-deno">全局空间 <code>Deno</code></a></h2>
<p>所有非 web 标准的 API 位于全局命名空间 <code>Deno</code>。</p>
<p>这其中包含文件读取、打开 TCP sockets、运行子进程等。</p>
<p>Deno 命名空间 的 TypeScript 定义：<a href="https://github.com/denoland/deno/blob/master/cli/dts/lib.deno.ns.d.ts">lib.deno.ns.d.ts</a></p>
<p>Deno 特定的 API 定义：<a href="https://doc.deno.land/https/raw.githubusercontent.com/denoland/deno/master/cli/dts/lib.deno.ns.d.ts">doc.deno.land</a></p>
<h2><a class="header" href="#稳定性" id="稳定性">稳定性</a></h2>
<p>从 Deno 1.0.0 开始，<code>Deno</code> 命名空间内的 API 是稳定的。这意味着我们将尽力使 1.0.0 下的代码在未来的 Deno 版本上继续运行。</p>
<p>但是在现阶段，并非所有的 Deno 功能都可以应用于生产环境。仍处于起草阶段的、还未准备完善的功能被锁定在 <code>--unstable</code> 命令行选项后。</p>
<pre><code class="language-shell">deno run --unstable mod_which_uses_unstable_stuff.ts
</code></pre>
<p>传递这个选项可以有如下效果：</p>
<ul>
<li>它将允许在运行时使用不稳定的 API。</li>
<li>它将 <a href="https://doc.deno.land/https/raw.githubusercontent.com/denoland/deno/master/cli/dts/lib.deno.unstable.d.ts"><code>lib.deno.unstable.d.ts</code></a> 文件添加到用于类型检查的类型脚本定义列表中。这包括 <code>deno types</code> 的输出。</li>
</ul>
<p>请注意，不稳定的 API 可能<strong>没有经过安全检查</strong>，将来可能有<strong>破坏性改动</strong>，并且<strong>还没有准备投入生产</strong>。</p>
<h3><a class="header" href="#标准模块" id="标准模块">标准模块</a></h3>
<p>Deno 的 <a href="https://deno.land/std/">标准模块</a> 尚不稳定。为了体现这点，我们用与 CLI 不同的版本号标记标准模块。和 <code>Deno</code> 命名空间不同，使用标准模块不需要 <code>--unstable</code> 选项（除非该模块使用了不稳定的 Deno 功能）。</p>
<h2><a class="header" href="#程序生命周期" id="程序生命周期">程序生命周期</a></h2>
<p>Deno 支持浏览器兼容的生命周期事件 <code>load</code> 和 <code>unload</code>。您可以使用这些事件在程序中提供用于安装 (setup) 和清理 (cleanup) 的代码。</p>
<p><code>load</code> 事件的侦听器 (listener) 可以是异步 (async) 的，将被等待 (await)。<code>unload</code> 事件的监听器需要是同步的。这两项事件都不能被取消。</p>
<p>示例：</p>
<p><strong>main.ts</strong></p>
<pre><code class="language-ts">import &quot;./imported.ts&quot;;

const handler = (e: Event): void =&gt; {
  console.log(`got ${e.type} event in event handler (main)`);
};

window.addEventListener(&quot;load&quot;, handler);

window.addEventListener(&quot;unload&quot;, handler);

window.onload = (e: Event): void =&gt; {
  console.log(`got ${e.type} event in onload function (main)`);
};

window.onunload = (e: Event): void =&gt; {
  console.log(`got ${e.type} event in onunload function (main)`);
};

console.log(&quot;log from main script&quot;);
</code></pre>
<p><strong>imported.ts</strong></p>
<pre><code class="language-ts">const handler = (e: Event): void =&gt; {
  console.log(`got ${e.type} event in event handler (imported)`);
};

window.addEventListener(&quot;load&quot;, handler);
window.addEventListener(&quot;unload&quot;, handler);

window.onload = (e: Event): void =&gt; {
  console.log(`got ${e.type} event in onload function (imported)`);
};

window.onunload = (e: Event): void =&gt; {
  console.log(`got ${e.type} event in onunload function (imported)`);
};

console.log(&quot;log from imported script&quot;);
</code></pre>
<p>注意，您可以同时使用 <code>window.addEventListener</code> 和 <code>window.onload</code> / <code>window.onunload</code> 来定义事件的处理程序。它们之间有一个主要的区别，让我们运行示例：</p>
<pre><code class="language-shell">$ deno run main.ts
log from imported script
log from main script
got load event in onload function (main)
got load event in event handler (imported)
got load event in event handler (main)
got unload event in onunload function (main)
got unload event in event handler (imported)
got unload event in event handler (main)
</code></pre>
<p>所有通过 <code>window.addEventListener</code> 添加的侦听器都被运行，但是在 <code>main.ts</code> 中定义的 <code>window.onload</code> 和 <code>window.onunload</code> 覆盖了 <code>imported.ts</code> 中定义的处理程序。</p>
<p>换句话说，您可以注册多个 <code>window.addEventListener</code> <code>&quot;load&quot;</code> 或
<code>&quot;unload&quot;</code> 事件，但只有最后加载的 <code>window.onload</code> 或 <code>window.onunload</code> 事件将被执行。</p>
<h2><a class="header" href="#编译器-api" id="编译器-api">编译器 API</a></h2>
<blockquote>
<p>这是一个不稳定的 Deno 特性。
更多信息请查阅 <a href="runtime/stability.html">稳定性</a></p>
</blockquote>
<p>Deno 支持对内置 TypeScript 编译器的运行时访问。<code>Deno</code> 命名空间中有三种方法提供此访问。</p>
<h3><a class="header" href="#denocompile" id="denocompile"><code>Deno.compile()</code></a></h3>
<p>这类似于 <code>deno cache</code>，因为它可以获取代码、缓存代码、编译代码，但不运行代码。它最多接受三个参数，<code>rootName</code>、可选的 <code>sources</code> 和可选的 <code>options</code>。</p>
<p><code>rootName</code> 是用于生成目标程序的根模块。这类似于在 <code>deno run --reload example.ts</code> 中在命令行上传递的模块名。</p>
<p><code>sources</code> 是一个哈希表，其中键是完全限定的模块名称，值是模块的文本源。如果传递了 <code>sources</code>，Deno 将从该哈希表中解析所有模块，而不会尝试在 Deno 之外解析它们。如果没有提供 <code>sources</code>，Deno 将解析模块，就像根模块已经在命令行上传递了一样。Deno 还将缓存所有的这些资源。所有已解析的资源都会被当成动态导入对待，导入行为是否需要读取和网络权限取决于目标在本地还是远程。</p>
<p><code>options</code> 参数是一组 <code>Deno.CompilerOptions</code> 类型的选项，它是包含 Deno 支持选项的 TypeScript 编译器选项的子集。</p>
<p>该方法返回元组。第一个参数包含与代码相关的任何诊断信息（语法或类型错误）。第二个参数是一个映射，其中键是输出文件名，值是内容。</p>
<p>提供 <code>sources</code> 的一个例子:</p>
<pre><code class="language-ts">const [diagnostics, emitMap] = await Deno.compile(&quot;/foo.ts&quot;, {
  &quot;/foo.ts&quot;: `import * as bar from &quot;./bar.ts&quot;;\nconsole.log(bar);\n`,
  &quot;/bar.ts&quot;: `export const bar = &quot;bar&quot;;\n`,
});

assert(diagnostics == null); // 确保没有返回诊断信息
console.log(emitMap);
</code></pre>
<p>我们希望 map 包含 4 个 “文件（files）” ，分别命名为 <code>/foo.js.map</code>，<code>/foo.js</code>，<code>/bar.js.map</code>，和 <code>/bar.js</code>。</p>
<p>当不提供资源时，您可以使用本地或远程模块，就像在命令行上做的那样。所以您可以这样做:</p>
<pre><code class="language-ts">const [diagnostics, emitMap] = await Deno.compile(
  &quot;https://deno.land/std/examples/welcome.ts&quot;,
);
</code></pre>
<p>在这种情况下，<code>emitMap</code> 将包含一个 <code>console.log()</code> 语句。</p>
<h3><a class="header" href="#denobundle" id="denobundle"><code>Deno.bundle()</code></a></h3>
<p>这与 <code>deno bundle</code> 在命令行上的工作非常相似。 它也与 <code>Deno.compile()</code> 类似，只是它不返回文件映射，而是只返回一个字符串，这是一个自包含的 JavaScript ES 模块，它将包含提供或解析的所有代码，以及提供的根模块的所有导出。它最多接受三个参数，<code>rootName</code>、可选的 <code>sources</code> 和可选的 <code>options</code>。</p>
<p><code>rootName</code> 是用于生成目标程序的根模块。这类似于在 <code>deno bundle example.ts</code> 中在命令行上传递的模块名。</p>
<p><code>sources</code> 是一个哈希表，其中键是完全限定的模块名称，值是模块的文本源。如果传递了 <code>sources</code>，Deno 将从该哈希表中解析所有模块，而不会尝试在 Deno 之外解析它们。如果没有提供 <code>sources</code>，Deno 将解析模块，就像根模块已经在命令行上传递了一样。Deno 还将缓存所有的这些资源。所有已解析的资源都会被当成动态导入对待，导入行为是否需要读取和网络权限取决于目标在本地还是远程。</p>
<p><code>options</code> 参数是一组 <code>Deno.CompilerOptions</code> 类型的选项，它是包含 Deno 支持选项的 TypeScript 编译器选项的子集。</p>
<p>提供 <code>sources</code> 的一个例子:</p>
<pre><code class="language-ts">const [diagnostics, emit] = await Deno.bundle(&quot;/foo.ts&quot;, {
  &quot;/foo.ts&quot;: `import * as bar from &quot;./bar.ts&quot;;\nconsole.log(bar);\n`,
  &quot;/bar.ts&quot;: `export const bar = &quot;bar&quot;;\n`,
});

assert(diagnostics == null); // 确保没有返回诊断信息
console.log(emit);
</code></pre>
<p>我们希望 <code>emit</code> 是一个 ES 模块的文本，它将包含两个模块的输出源。</p>
<p>当不提供资源时，您可以使用本地或远程模块，就像在命令行上做的那样。所以您可以这样做:</p>
<pre><code class="language-ts">const [diagnostics, emit] = await Deno.bundle(
  &quot;https://deno.land/std/http/server.ts&quot;,
);
</code></pre>
<p>在这种情况下，<code>emit</code> 将是一个自包含的 JavaScript ES 模块，并解析了所有依赖项，导出与源模块相同的导出。</p>
<h3><a class="header" href="#denotranspileonly" id="denotranspileonly"><code>Deno.transpileOnly()</code></a></h3>
<p>这是基于 TypeScript 函数 <code>transpileModule()</code> 的。所有这些操作都会“擦除”模块中的任何类型并释放 JavaScript。没有类型检查和依赖关系的解析。它最多接受两个参数，第一个参数是哈希表，其中键是模块名称，值是内容。模块名称的唯一用途是在将信息放入源映射时，显示源文件名称是什么。第二个参数包含 <code>Deno.CompilerOptions</code> 类型的可选 <code>options</code>。函数通过映射解析，其中键是提供的源模块名称，值是具有 <code>source</code> 属性和可选 <code>map</code> 属性的对象。第一个是模块的输出内容。 <code>map</code> 属性是源映射。源映射是默认提供的，但可以通过 <code>options</code> 参数关闭。</p>
<p>举个例子：</p>
<pre><code class="language-ts">const result = await Deno.transpileOnly({
  &quot;/foo.ts&quot;: `enum Foo { Foo, Bar, Baz };\n`,
});

console.log(result[&quot;/foo.ts&quot;].source);
console.log(result[&quot;/foo.ts&quot;].map);
</code></pre>
<p>我们期望 <code>enum</code> 被重写成一个构造可枚举的 IIFE，并且映射被定义。</p>
<h3><a class="header" href="#引用-typescript-库文件" id="引用-typescript-库文件">引用 TypeScript 库文件</a></h3>
<p>当您使用 <code>deno run</code> 或其他 TypeScript 类型的 Deno 命令时，该代码将根据描述 Deno 支持的环境的自定义库进行评估。默认情况下，TypeScript 类型的编译器运行时 API 也使用这些库（<code>Deno.compile()</code> 和 <code>Deno.bundle()</code>）。</p>
<p>但是，如果您希望为其他运行时编译或捆绑 TypeScript，则您可能希望重载默认库。为此，运行时 API 支持编译器选项中的 <code>lib</code> 属性。例如，如果你的 TypeScript 代码是为浏览器准备的，您可以使用 TypeScript 的 <code>&quot;dom&quot;</code> 库:</p>
<pre><code class="language-ts">const [errors, emitted] = await Deno.compile(
  &quot;main.ts&quot;,
  {
    &quot;main.ts&quot;: `document.getElementById(&quot;foo&quot;);\n`,
  },
  {
    lib: [&quot;dom&quot;, &quot;esnext&quot;],
  },
);
</code></pre>
<p>有关 TypeScript 支持的所有库的列表，请参见 <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html"><code>lib</code> 编译器选项</a>。
<strong>不要忘记包含 JavaScript 库</strong></p>
<p>就像 <code>tsc</code> 一样，当您提供一个 <code>lib</code> 编译器选项时，它会覆盖默认的选项，这意味着基本的 JavaScript 库不会被包含，而您应该包含最能代表您的目标运行时的选项（例如 <code>es5</code>，<code>es2015</code>，<code>es2016</code>，<code>es2017</code>，<code>es2018</code>，<code>es2019</code>，<code>es2020</code> 或 <code>esnext</code>）。</p>
<h4><a class="header" href="#包含-deno-命名空间" id="包含-deno-命名空间">包含 Deno 命名空间</a></h4>
<p>除了 TypeScript 提供的库之外，还有四个内置在 Deno 中的库可以引用:</p>
<ul>
<li><code>deno.ns</code> - 提供 <code>Deno</code> 命名空间</li>
<li><code>deno.shared_globals</code> - 提供 Deno 运行时支持的全局接口和变量，然后由最终运行时库公开</li>
<li><code>deno.window</code> - 公开全局变量和 Deno 主工作进程中可用的 Deno 命名空间，是运行时编译器的默认 API</li>
<li><code>deno.worker</code> - 公开在 Deno 下的工作进程中可用的全局变量。</li>
</ul>
<p>因此，要将 Deno 命名空间添加到编译中，需要在数组中包含 <code>deno.ns</code> 库，例如：</p>
<pre><code class="language-ts">const [errors, emitted] = await Deno.compile(
  &quot;main.ts&quot;,
  {
    &quot;main.ts&quot;: `document.getElementById(&quot;foo&quot;);\n`,
  },
  {
    lib: [&quot;dom&quot;, &quot;esnext&quot;, &quot;deno.ns&quot;],
  },
);
</code></pre>
<p><strong>注意</strong>，Deno 命名空间需要一个 ES2018 或更新的运行时环境。这意味着，如果您使用的库“低于” ES2018，那么您将得到编译过程中输出的错误。</p>
<h4><a class="header" href="#使用三斜杠引用triple-slash-reference" id="使用三斜杠引用triple-slash-reference">使用三斜杠引用（triple-slash reference）</a></h4>
<p>您不必在编译器选项中指定 <code>lib</code>。Deno 支持<a href="https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-reference-lib-">对库的三斜杠引用</a>，并可以嵌入到文件的内容中。举个例子，如果你有一个 <code>main.ts</code>：</p>
<pre><code class="language-ts">/// &lt;reference lib=&quot;dom&quot; /&gt;

document.getElementById(&quot;foo&quot;);
</code></pre>
<p>它可以编译，且不会出现下面这样的错误：</p>
<pre><code class="language-ts">const [errors, emitted] = await Deno.compile(&quot;./main.ts&quot;, undefined, {
  lib: [&quot;esnext&quot;],
});
</code></pre>
<p><strong>注意</strong>，<code>dom</code> 库与 Deno 的默认类型库中定义的一些默认全局变量有冲突。为了避免这种情况，需要在编译器选项中为运行时编译器 API 指定一个 <code>lib</code> 选项。</p>
<h2><a class="header" href="#worker" id="worker">Worker</a></h2>
<p>Deno 支持 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Worker/Worker">Web Worker API</a>.</p>
<p>Worker 能够用来在多个线程中运行代码，<code>Worker</code> 的每个实例都会在一个单独的线程中运行，这个线程专属于它。</p>
<p>目前，Deno 只支持 <code>module</code> 类型的 worker，因此在创建新的 worker 时必须传递 <code>type: &quot;module&quot;</code> 选项。</p>
<p>目前，相对模块说明符 (Relative module specifiers) <a href="https://github.com/denoland/deno/issues/5216">尚不支持</a>。作为代替，您可以用 <code>URL</code> 构造函数和 <code>import.meta.url</code> 来为附近的脚本创建说明符。</p>
<pre><code class="language-ts">// Good
new Worker(new URL(&quot;worker.js&quot;, import.meta.url).href, { type: &quot;module&quot; });

// Bad
new Worker(new URL(&quot;worker.js&quot;, import.meta.url).href);
new Worker(new URL(&quot;worker.js&quot;, import.meta.url).href, { type: &quot;classic&quot; });
new Worker(&quot;./worker.js&quot;, { type: &quot;module&quot; });
</code></pre>
<h3><a class="header" href="#权限-1" id="权限-1">权限</a></h3>
<p>创建一个新的 <code>Worker</code> 实例的行为与动态导入类似，因此 Deno 需要适当的权限来做这个操作。</p>
<p>对于使用本地模块的 worker，Deno 需要读取 (<code>--allow-read</code>) 权限：</p>
<p><strong>main.ts</strong></p>
<pre><code class="language-ts">new Worker(new URL(&quot;worker.ts&quot;, import.meta.url).href, { type: &quot;module&quot; });
</code></pre>
<p><strong>worker.ts</strong></p>
<pre><code class="language-ts">console.log(&quot;hello world&quot;);
self.close();
</code></pre>
<pre><code class="language-shell">$ deno run main.ts
error: Uncaught PermissionDenied: read access to &quot;./worker.ts&quot;, run again with the --allow-read flag

$ deno run --allow-read main.ts
hello world
</code></pre>
<p>对于使用远程模块的 worker，Deno 需要网络 (<code>--allow-net</code>) 权限：</p>
<p><strong>main.ts</strong></p>
<pre><code class="language-ts">new Worker(&quot;https://example.com/worker.ts&quot;, { type: &quot;module&quot; });
</code></pre>
<p><strong>worker.ts</strong></p>
<pre><code class="language-ts">console.log(&quot;hello world&quot;);
self.close();
</code></pre>
<pre><code class="language-shell">$ deno run main.ts
error: Uncaught PermissionDenied: net access to &quot;https://example.com/worker.ts&quot;, run again with the --allow-net flag

$ deno run --allow-net main.ts
hello world
</code></pre>
<h3><a class="header" href="#在-worker-中使用-deno" id="在-worker-中使用-deno">在 Worker 中使用 Deno</a></h3>
<blockquote>
<p>这是一个不稳定的 Deno 特性。
更多信息请查阅 <a href="runtime/stability.html">稳定性</a></p>
</blockquote>
<p>默认情况下，<code>Deno</code> 命名空间在 worker 作用域中不可用。</p>
<p>要想启用 <code>Deno</code> 命名空间，在创建新的 worker 时传递 <code>deno: true</code> 选项：</p>
<p><strong>main.js</strong></p>
<pre><code class="language-ts">const worker = new Worker(new URL(&quot;worker.js&quot;, import.meta.url).href, {
  type: &quot;module&quot;,
  deno: true,
});
worker.postMessage({ filename: &quot;./log.txt&quot; });
</code></pre>
<p><strong>worker.js</strong></p>
<pre><code class="language-ts">self.onmessage = async (e) =&gt; {
  const { filename } = e.data;
  const text = await Deno.readTextFile(filename);
  console.log(text);
  self.close();
};
</code></pre>
<p><strong>log.txt</strong></p>
<pre><code>hello world
</code></pre>
<pre><code class="language-shell">$ deno run --allow-read --unstable main.js
hello world
</code></pre>
<p>当 <code>Deno</code> 命名空间在 worker 作用域中启用时，此 worker 继承创建者的权限（使用类似 <code>--allow-*</code> 的选项指定的权限）。</p>
<p>我们计划提供 worker 权限的配置方法。</p>
<h1><a class="header" href="#与外部代码连接" id="与外部代码连接">与外部代码连接</a></h1>
<p>在 <a href="./getting_started.html">入门</a> 章节中，我们看到 Deno 能够从 URL 执行脚本。像浏览器中的 JavaScript 一样，Deno 可以从 URL 直接导入代码库。</p>
<p>这个示例使用 URL 来导入一个断言库：</p>
<p><strong>test.ts</strong></p>
<pre><code class="language-ts">import { assertEquals } from &quot;https://deno.land/std/testing/asserts.ts&quot;;

assertEquals(&quot;hello&quot;, &quot;hello&quot;);
assertEquals(&quot;world&quot;, &quot;world&quot;);

console.log(&quot;Asserted! ✓&quot;);
</code></pre>
<p>尝试运行一下：</p>
<pre><code class="language-shell">$ deno run test.ts
Compile file:///mnt/f9/Projects/github.com/denoland/deno/docs/test.ts
Download https://deno.land/std/testing/asserts.ts
Download https://deno.land/std/fmt/colors.ts
Download https://deno.land/std/testing/diff.ts
Asserted! ✓
</code></pre>
<p>对于这个程序，我们不需要提供 <code>--allow-net</code> 选项。当它访问网络时，Deno 运行时有着特殊权限来下载模块并缓存到磁盘。</p>
<p>Deno 在一个特殊目录缓存了远程模块，该路径可以被 <code>DENO_DIR</code> 指定，如果没有指定，默认为系统缓存目录。下一次运行这个程序时无需下载。如果这个程序没有改动，它不会被再次编译。</p>
<p>系统缓存目录默认为：</p>
<ul>
<li>Linux/Redox: <code>$XDG_CACHE_HOME/deno</code> or <code>$HOME/.cache/deno</code></li>
<li>Windows: <code>%LOCALAPPDATA%/deno</code> (<code>%LOCALAPPDATA%</code> = <code>FOLDERID_LocalAppData</code>)</li>
<li>macOS: <code>$HOME/Library/Caches/deno</code></li>
</ul>
<p>如果失败，该路径设置为 <code>$HOME/.deno</code>。</p>
<h2><a class="header" href="#faq" id="faq">FAQ</a></h2>
<h3><a class="header" href="#如何导入特定版本" id="如何导入特定版本">如何导入特定版本？</a></h3>
<p>只需在 URL 中指定版本。举个例子，这个 URL 指定了要运行的版本 <code>https://unpkg.com/liltest@0.0.5/dist/liltest.js</code>。</p>
<h3><a class="header" href="#到处导入-url-似乎很麻烦" id="到处导入-url-似乎很麻烦">到处导入 URL 似乎很麻烦</a></h3>
<blockquote>
<p>如果其中一个 URL 链接到一个完全不同的库版本，该怎么办？</p>
</blockquote>
<blockquote>
<p>在大型项目中到处维护 URL 是否容易出错？</p>
</blockquote>
<p>解决办法是在一个中心化的 <code>deps.ts</code> 中重新导出所依赖的外部库，它和 Node 的 <code>package.json</code> 具有相同的作用。</p>
<p>举个例子，您正在一个大型项目中使用一个断言库，您可以创建一个 <code>deps.ts</code> 文件来导出第三方代码，而不是到处导入 <code>&quot;https://deno.land/std/testing/asserts.ts&quot;</code>。</p>
<p><strong>deps.ts</strong></p>
<pre><code class="language-ts">export {
  assert,
  assertEquals,
  assertStrContains,
} from &quot;https://deno.land/std/testing/asserts.ts&quot;;
</code></pre>
<p>在这个项目中，您可以从 <code>deps.ts</code> 导入，避免对相同的 URL 产生过多引用。</p>
<pre><code class="language-ts">import { assertEquals, runTests, test } from &quot;./deps.ts&quot;;
</code></pre>
<p>这种设计避免了由包管理软件、集中的代码存储库和多余的文件格式所产生的大量复杂性。</p>
<h3><a class="header" href="#如何信任可能更改的-url" id="如何信任可能更改的-url">如何信任可能更改的 URL？</a></h3>
<p>使用 <code>--lock</code> 命令行选项，通过一个锁文件 (lock file)，您可以确保从一个 URL 下载的代码和初始开发时一样。更多信息请看 <a href="./linking_to_external_code/integrity_checking.html">这里</a>。</p>
<h3><a class="header" href="#如果依赖宕机怎么办源代码将不再可用" id="如果依赖宕机怎么办源代码将不再可用">如果依赖宕机怎么办？源代码将不再可用。</a></h3>
<p>像上面一样，这是 <em>任何</em> 远程依赖系统都要面对的问题。</p>
<p>依赖外部服务在开发时很方便，但在生产环境很脆弱。生产级软件总是应该打包 (vendor) 所有依赖。</p>
<p>在 Node 中，这需要将 <code>node_modules</code> 检入版本控制系统。</p>
<p>在 Deno 中，这需要在运行时将 <code>$DENO_DIR</code> 指向项目内的目录，同样把依赖检入版本控制系统。</p>
<pre><code class="language-shell"># 下载依赖
DENO_DIR=./deno_dir deno cache src/deps.ts

# 确保需要缓存的任何命令都设置了 `DENO_DIR` 变量
DENO_DIR=./deno_dir deno test src

# 将缓存目录检入版本控制
git add -u deno_dir
git commit
</code></pre>
<h2><a class="header" href="#重新加载特定的模块" id="重新加载特定的模块">重新加载特定的模块</a></h2>
<p>默认情况下，缓存中的模块将被重用，而无需获取或重新编译它。有时这不是期望的行为，您可以强制 deno 重新下载模块并重新编译到缓存中。您可以使用 <code>deno cache</code> 子命令的<code>--reload</code> 选项来使本地 <code>DENO_DIR</code> 缓存无效。</p>
<p>其用法描述如下：</p>
<h3><a class="header" href="#重新加载所有内容" id="重新加载所有内容">重新加载所有内容</a></h3>
<pre><code class="language-ts">deno cache --reload my_module.ts
</code></pre>
<h3><a class="header" href="#重新加载指定模块" id="重新加载指定模块">重新加载指定模块</a></h3>
<p>有时我们只想升级某些模块，可以通过将参数传递给 <code>--reload</code> 选项来控制它。</p>
<p>重新加载所有 v0.55.0 的标准模块：</p>
<pre><code class="language-ts">deno cache --reload=https://deno.land/std@v0.55.0 my_module.ts
</code></pre>
<p>为了重新加载特定的模块（在这个例子中是 colors 和 file system copy），需要使用逗号来分隔 URL：</p>
<pre><code class="language-ts">deno cache --reload=https://deno.land/std/fs/copy.ts,https://deno.land/std/fmt/colors.ts my_module.ts
</code></pre>
<!-- Should this be part of examples? -->
<h2><a class="header" href="#完整性检查与锁定文件" id="完整性检查与锁定文件">完整性检查与锁定文件</a></h2>
<h3><a class="header" href="#介绍-1" id="介绍-1">介绍</a></h3>
<p>假设您的模块依赖于远程模块 <code>https://some.url/a.ts</code>。当第一次编译您的模块时，<code>a.ts</code> 被下载、编译、缓存。它将保持这样，直到您在一个新的机器上运行您的模块（生产环境？）或是重新加载缓存（例如通过 <code>deno cache --reload</code>）。但当 <code>https://some.url/a.ts</code> 的内容变化时会发生什么？这将导致您的生产模块使用了和本地模块不同的依赖。Deno 的解决方法是使用完整性检查与锁定文件。</p>
<h3><a class="header" href="#缓存与锁定文件" id="缓存与锁定文件">缓存与锁定文件</a></h3>
<p>Deno 可以使用一个较小的 JSON 文件存储和检查模块的子资源完整性。</p>
<p>使用 <code>--lock=lock.json</code> 启用和指定锁文件检查。</p>
<p>要更新或创建锁，可以使用 <code>--lock=lock.json --lock-write</code>。<code>--lock=lock.json</code> 告诉 Deno 要使用哪个锁文件，<code>--lock-write</code> 用来向锁文件输出依赖的哈希值。 （<code>--lock-write</code> 必须和 <code>--lock</code> 一起使用）</p>
<p>一个锁文件可能看起来像这样，针对依赖项存储文件的哈希值：</p>
<pre><code class="language-json">{
  &quot;https://deno.land/std@v0.50.0/textproto/mod.ts&quot;: &quot;3118d7a42c03c242c5a49c2ad91c8396110e14acca1324e7aaefd31a999b71a4&quot;,
  &quot;https://deno.land/std@v0.50.0/io/util.ts&quot;: &quot;ae133d310a0fdcf298cea7bc09a599c49acb616d34e148e263bcb02976f80dee&quot;,
  &quot;https://deno.land/std@v0.50.0/async/delay.ts&quot;: &quot;35957d585a6e3dd87706858fb1d6b551cb278271b03f52c5a2cb70e65e00c26a&quot;,
   ...
}
</code></pre>
<p>一个典型的工作流看起来像这样：</p>
<pre><code class="language-ts">// 向 &quot;src/deps.ts&quot; 添加一个新的依赖，在别处使用。
export { xyz } from &quot;https://unpkg.com/xyz-lib@v0.9.0/lib.ts&quot;;
</code></pre>
<pre><code class="language-shell"># 创建或更新锁文件 &quot;lock.json&quot;
deno cache --lock=lock.json --lock-write src/deps.ts

# 在提交时包含这一变化
git add -u lock.json
git commit -m &quot;feat: Add support for xyz using xyz-lib&quot;
git push
</code></pre>
<p>另一台机器上的合作者刚刚把项目克隆下来：</p>
<pre><code class="language-shell"># 下载、缓存并检查项目的依赖
deno cache -r --lock=lock.json src/deps.ts

# 在这完成之后，您可以安心开发了
deno test --allow-read src
</code></pre>
<h3><a class="header" href="#运行时验证" id="运行时验证">运行时验证</a></h3>
<p>像上面的缓存一样，您也可以在使用 <code>deno run</code> 子命令时配合<code>--lock=lock.json</code> 选项，从而在运行期间验证所有被锁定的模块的完整性。请记住，这只会针对先前添加到 <code>lock.json</code> 文件中的依赖项进行验证。新的依赖项将被缓存，但不会被检验。</p>
<p>您也可以通过使用 <code>--cached-only</code> 选项来要求远程依赖都已经被缓存。</p>
<pre><code class="language-shell">deno run --lock=lock.json --cached-only mod.ts
</code></pre>
<p>如果依赖树中有尚未缓存的 mod.ts 依赖项，此操作将失败。</p>
<!-- TODO - Add detail on dynamic imports -->
<h2><a class="header" href="#代理proxies" id="代理proxies">代理（Proxies）</a></h2>
<p>Deno 支持模块下载和 Web 标准 <code>fetch</code> API 的代理。</p>
<p>代理配置从环境变量中读取: <code>HTTP_PROXY</code> 和 <code>HTTPS_PROXY</code>。</p>
<p>在 Windows 的环境下，如果没有发现环境变量，Deno 会从注册表中读取代理。</p>
<h2><a class="header" href="#导入映射import-maps" id="导入映射import-maps">导入映射（Import maps）</a></h2>
<blockquote>
<p>这是一个不稳定的特性。
更多信息请查阅 <a href="linking_to_external_code/../runtime/stability.html">稳定性</a></p>
</blockquote>
<p>Deno 支持 <a href="https://github.com/WICG/import-maps">导入映射</a>。</p>
<p>您可以通过 <code>--importmap=&lt;FILE&gt;</code> 的命令行选项使用导入映射。</p>
<p>目前的限制:</p>
<ul>
<li>只支持单个导入映射</li>
<li>没有 fallback URL</li>
<li>Deno 不支持 <code>std:</code> 命名空间</li>
<li>仅支持 <code>file:</code>，<code>http:</code> 和 <code>https:</code> 协议</li>
</ul>
<p>示例：</p>
<p><strong>import_map.json</strong></p>
<pre><code class="language-js">{
   &quot;imports&quot;: {
      &quot;fmt/&quot;: &quot;https://deno.land/std@0.55.0/fmt/&quot;
   }
}
</code></pre>
<p><strong>color.ts</strong></p>
<pre><code class="language-ts">import { red } from &quot;fmt/colors.ts&quot;;

console.log(red(&quot;hello world&quot;));
</code></pre>
<p>运行：</p>
<pre><code class="language-shell">$ deno run --importmap=import_map.json --unstable color.ts
</code></pre>
<p>为绝对导入使用起始目录：</p>
<pre><code class="language-json">// import_map.json

{
  &quot;imports&quot;: {
    &quot;/&quot;: &quot;./&quot;
  }
}
</code></pre>
<pre><code class="language-ts">// main.ts

import { MyUtil } from &quot;/util.ts&quot;;
</code></pre>
<p>您可以映射一个不同的目录（比如 src）：</p>
<pre><code class="language-json">// import_map.json

{
  &quot;imports&quot;: {
    &quot;/&quot;: &quot;./src&quot;
  }
}
</code></pre>
<h1><a class="header" href="#标准库" id="标准库">标准库</a></h1>
<p>Deno 提供一组标准模块，它们经过核心团队审计，保证能在 Deno 上工作。</p>
<p>标准库地址：<a href="https://deno.land/std/">https://deno.land/std/</a></p>
<h2><a class="header" href="#版本和稳定性" id="版本和稳定性">版本和稳定性</a></h2>
<p>标准库尚不稳定，因此采用与 Deno 不同的版本号。每次 Deno 发布时，标准库也会一起发布。</p>
<p>最新的发布请查阅 <a href="https://deno.land/std/">https://deno.land/std/</a> 或 <a href="https://deno.land/std/version.ts">https://deno.land/std/version.ts</a>。</p>
<p>我们强烈建议：始终使用确定版本的标准库，以避免意外的改动。</p>
<p>例如，连接到随时可能更改的主分支时可能会导致编译错误或意外行为：</p>
<pre><code class="language-typescript">// 从 master 导入，这应当避免
import { copy } from &quot;https://deno.land/std/fs/copy.ts&quot;;
</code></pre>
<p>更好的选择是使用不可变且不会更改的 std 库版本：</p>
<pre><code class="language-typescript">// 从不可变的 std v0.50.0 导入
import { copy } from &quot;https://deno.land/std@0.50.0/fs/copy.ts&quot;;
</code></pre>
<h2><a class="header" href="#排错-troubleshooting" id="排错-troubleshooting">排错 (Troubleshooting)</a></h2>
<p>标准库中的一些模块使用了不稳定的 Deno API。</p>
<p>不用 <code>--unstable</code> 命令行选项运行这些模块会产生一些 TypeScript 错误，表示 <code>Deno</code> 命名空间中不存在一些 API：</p>
<pre><code class="language-typescript">// main.ts
import { copy } from &quot;https://deno.land/std@0.50.0/fs/copy.ts&quot;;

copy(&quot;log.txt&quot;, &quot;log-old.txt&quot;);
</code></pre>
<pre><code class="language-shell">$ deno run --allow-read --allow-write main.ts
Compile file:///dev/deno/main.ts
Download https://deno.land/std@0.50.0/fs/copy.ts
Download https://deno.land/std@0.50.0/fs/ensure_dir.ts
Download https://deno.land/std@0.50.0/fs/_util.ts
error: TS2339 [ERROR]: Property 'utime' does not exist on type 'typeof Deno'.
    await Deno.utime(dest, statInfo.atime, statInfo.mtime);
               ~~~~~
    at https://deno.land/std@0.50.0/fs/copy.ts:90:16

TS2339 [ERROR]: Property 'utimeSync' does not exist on type 'typeof Deno'.
    Deno.utimeSync(dest, statInfo.atime, statInfo.mtime);
         ~~~~~~~~~
    at https://deno.land/std@0.50.0/fs/copy.ts:101:10
</code></pre>
<p>解决方法是加上 <code>--unstable</code> 选项：</p>
<pre><code class="language-shell">deno run --allow-read --allow-write --unstable main.ts
</code></pre>
<p>要确定哪些 API 是不稳定的，请查阅类型声明 <a href="https://github.com/denoland/deno/blob/master/cli/dts/lib.deno.unstable.d.ts">lib.deno.unstable.d.ts</a></p>
<p>这个问题会在不远的将来解决。如果您依赖的特定模块在没有该选项的情况下成功编译，则可以忽略该选项。</p>
<h1><a class="header" href="#测试" id="测试">测试</a></h1>
<p>Deno 有一个内置的测试器，可以用来测试 JavaScript 或 TypeScript 代码。</p>
<h2><a class="header" href="#编写测试" id="编写测试">编写测试</a></h2>
<p>要定义测试，需要使用要测试的名称和函数调用 <code>Deno.test</code>。</p>
<p>您可以使用两种风格：</p>
<pre><code class="language-ts">// 传递名称和函数，紧凑的形式，但不能配置
Deno.test(&quot;hello world #1&quot;, () =&gt; {
  const x = 1 + 2;
  assertEquals(x, 3);
});

// 全面的测试定义，更长的形式，但可配置（请参见下文）
Deno.test({
  name: &quot;hello world #2&quot;,
  fn: () =&gt; {
    const x = 1 + 2;
    assertEquals(x, 3);
  },
});
</code></pre>
<h2><a class="header" href="#断言" id="断言">断言</a></h2>
<p>在 <a href="https://deno.land/std/testing#usage">https://deno.land/std/testing</a> 上有一些有用的断言实用程序，可以简化测试：</p>
<pre><code class="language-ts">import {
  assertEquals,
  assertArrayContains,
} from &quot;https://deno.land/std/testing/asserts.ts&quot;;

Deno.test(&quot;hello world&quot;, () =&gt; {
  const x = 1 + 2;
  assertEquals(x, 3);
  assertArrayContains([1, 2, 3, 4, 5, 6], [3], &quot;Expected 3 to be in the array&quot;);
});
</code></pre>
<h3><a class="header" href="#异步函数" id="异步函数">异步函数</a></h3>
<p>您还可以通过传递一个测试函数来测试异步代码，该函数返回一个 promise。
为此，您可以在定义函数时使用 <code>async</code> 关键字：</p>
<pre><code class="language-ts">import { delay } from &quot;https://deno.land/std/async/delay.ts&quot;;

Deno.test(&quot;async hello world&quot;, async () =&gt; {
  const x = 1 + 2;

  // await some async task
  await delay(100);

  if (x !== 3) {
    throw Error(&quot;x should be equal to 3&quot;);
  }
});
</code></pre>
<h3><a class="header" href="#资源和异步操作清理器" id="资源和异步操作清理器">资源和异步操作清理器</a></h3>
<p>Deno 中的某些操作在资源表（<a href="./contributing/architecture.html">在此处了解更多</a>）中创建资源。
这些资源应该在使用完后关闭。</p>
<p>对于每个测试定义，测试器会检查此测试中创建的所有资源是否已关闭，以防止资源“泄漏”。
默认情况下，这对所有测试都是启用的，但可以通过在测试定义中将 <code>sanitizeResources</code> 布尔值设置为 false 来禁用。</p>
<p>对于异步操作（如与文件系统交互）也是如此。测试器检查您在测试中启动的每个操作是否在测试结束之前完成。默认情况下，这对所有测试都是启用的，但可以通过在测试定义中将 <code>sanitizeps</code> 布尔值设置为 false 来禁用。</p>
<pre><code class="language-ts">Deno.test({
  name: &quot;leaky test&quot;,
  fn() {
    Deno.open(&quot;hello.txt&quot;);
  },
  sanitizeResources: false,
  sanitizeOps: false,
});
</code></pre>
<h2><a class="header" href="#运行测试" id="运行测试">运行测试</a></h2>
<p>要运行测试，使用 <code>deno test</code> 命令，传入包含测试函数的文件。您也可以忽略文件名，这样当前目录树内所有符合通配符 <code>{*_,*.,}test.{js,mjs,ts,jsx,tsx}</code> 的测试都会被运行。如果您传入了一个目录，那么该目录下所有匹配的文件都会被运行。</p>
<pre><code class="language-shell"># 运行当前目录树内的所有测试
deno test

# 运行 util 目录内的所有测试
deno test util/

# 只运行 my_test.ts
deno test my_test.ts
</code></pre>
<p><code>deno test</code> 和 <code>deno run</code> 使用相同的权限模型，比如在测试期间有可能要求 <code>--allow-write</code> 来写入文件系统。</p>
<p>使用 <code>deno help test</code> 命令来查看相关选项。</p>
<h2><a class="header" href="#过滤" id="过滤">过滤</a></h2>
<p>有许多选项可以过滤要运行的测试。</p>
<h3><a class="header" href="#命令行过滤" id="命令行过滤">命令行过滤</a></h3>
<p>使用 <code>--filter</code> 选项可以单独或成组运行测试。</p>
<p>该选项接受一个字符串或一个模式作为值。</p>
<p>假设有以下测试：</p>
<pre><code class="language-ts">Deno.test({ name: &quot;my-test&quot;, fn: myTest });
Deno.test({ name: &quot;test-1&quot;, fn: test1 });
Deno.test({ name: &quot;test2&quot;, fn: test2 });
</code></pre>
<p>以下命令将会运行所有包含 &quot;test&quot; 的测试：</p>
<pre><code class="language-shell">deno test --filter &quot;test&quot; tests/
</code></pre>
<p>以下命令将会运行匹配该模式的测试，即第二个和第三个：</p>
<pre><code class="language-shell">deno test --filter &quot;/test-*\d/&quot; tests/
</code></pre>
<p>像 JavaScript 的正则表达式语法糖一样，Deno 会将用斜杠包裹的过滤字符串认为是模式。</p>
<h3><a class="header" href="#测试定义过滤" id="测试定义过滤">测试定义过滤</a></h3>
<p>在测试本身中，您有两个过滤选项。</p>
<h4><a class="header" href="#忽略测试" id="忽略测试">忽略测试</a></h4>
<p>有时您希望忽略基于某种条件的测试（例如您只希望在 Windows 上运行测试）。
为此，您可以使用 <code>ignore</code> 测试定义中的布尔值。
如果它被设置为 true，则测试将被跳过。</p>
<pre><code class="language-ts">Deno.test({
  name: &quot;do macOS feature&quot;,
  ignore: Deno.build.os !== &quot;darwin&quot;,
  fn() {
    doMacOSFeature();
  },
});
</code></pre>
<h4><a class="header" href="#启用测试" id="启用测试">启用测试</a></h4>
<p>有时您可能会在大型测试中遇到问题，只想专注于有问题的测试，忽略其他测试。</p>
<p>为此您可以使用 <code>only</code> 选项来让测试框架只运行一部分测试。多个测试可以设置此选项。尽管测试框架将报告每个测试的成功或失败，但当任何一个测试标记为 <code>only</code> 时，总体测试将始终失败。因为这只是一种临时措施，几乎会禁用所有测试。</p>
<pre><code class="language-ts">Deno.test({
  name: &quot;Focus on this test only&quot;,
  only: true,
  fn() {
    testComplicatedStuff();
  },
});
</code></pre>
<h2><a class="header" href="#快速失败" id="快速失败">快速失败</a></h2>
<p>如果您有一个运行时间较长的测试，并希望它在第一次失败时停止运行，则可以在运行测试时指定 <code>--failfast</code> 选项。</p>
<pre><code class="language-shell">deno test --failfast
</code></pre>
<h2><a class="header" href="#断言-1" id="断言-1">断言</a></h2>
<p>为了帮助开发者编写测试，Deno 标准库提供了内置的 <a href="https://deno.land/std/testing/asserts.ts">断言模块</a>，可从 <code>https://deno.land/std/testing/asserts.ts</code> 导入。</p>
<pre><code class="language-js">import { assert } from &quot;https://deno.land/std/testing/asserts.ts&quot;;

Deno.test(&quot;Hello Test&quot;, () =&gt; {
  assert(&quot;Hello&quot;);
});
</code></pre>
<p>断言模块提供了九个断言函数：</p>
<ul>
<li><code>assert(expr: unknown, msg = &quot;&quot;): asserts expr</code></li>
<li><code>assertEquals(actual: unknown, expected: unknown, msg?: string): void</code></li>
<li><code>assertNotEquals(actual: unknown, expected: unknown, msg?: string): void</code></li>
<li><code>assertStrictEquals(actual: unknown, expected: unknown, msg?: string): void</code></li>
<li><code>assertStringContains(actual: string, expected: string, msg?: string): void</code></li>
<li><code>assertArrayContains(actual: unknown[], expected: unknown[], msg?: string): void</code></li>
<li><code>assertMatch(actual: string, expected: RegExp, msg?: string): void</code></li>
<li><code>assertThrows(fn: () =&gt; void, ErrorClass?: Constructor, msgIncludes = &quot;&quot;, msg?: string): Error</code></li>
<li><code>assertThrowsAsync(fn: () =&gt; Promise&lt;void&gt;, ErrorClass?: Constructor, msgIncludes = &quot;&quot;, msg?: string): Promise&lt;Error&gt;</code></li>
</ul>
<h3><a class="header" href="#断言-2" id="断言-2">断言</a></h3>
<p><code>assert</code> 方法是一个简单的“真值”断言，可用于断言任何可以推导为 <code>true</code> 的值。</p>
<pre><code class="language-js">Deno.test(&quot;Test Assert&quot;, () =&gt; {
  assert(1);
  assert(&quot;Hello&quot;);
  assert(true);
});
</code></pre>
<h3><a class="header" href="#相等性" id="相等性">相等性</a></h3>
<p>可用的相等性断言有三个：<code>assertEquals()</code>，<code>assertNotEquals()</code> 和 <code>assertStrictEquals()</code>.</p>
<p><code>assertEquals()</code> 和 <code>assertNotEquals()</code> 方法提供常规的相等性检查，并能够断言基本类型和对象的相等性。</p>
<pre><code class="language-js">Deno.test(&quot;Test Assert Equals&quot;, () =&gt; {
  assertEquals(1, 1);
  assertEquals(&quot;Hello&quot;, &quot;Hello&quot;);
  assertEquals(true, true);
  assertEquals(undefined, undefined);
  assertEquals(null, null);
  assertEquals(new Date(), new Date());
  assertEquals(new RegExp(&quot;abc&quot;), new RegExp(&quot;abc&quot;));

  class Foo {}
  const foo1 = new Foo();
  const foo2 = new Foo();

  assertEquals(foo1, foo2);
});

Deno.test(&quot;Test Assert Not Equals&quot;, () =&gt; {
  assertNotEquals(1, 2);
  assertNotEquals(&quot;Hello&quot;, &quot;World&quot;);
  assertNotEquals(true, false);
  assertNotEquals(undefined, &quot;&quot;);
  assertNotEquals(new Date(), Date.now());
  assertNotEquals(new RegExp(&quot;abc&quot;), new RegExp(&quot;def&quot;));
});
</code></pre>
<p><code>assertStrictEquals()</code> 基于 <code>===</code> 运算符提供了更简单、严格的检查。相同对象的两个实例不会判断为相等，因为引用不相同。</p>
<pre><code class="language-js">Deno.test(&quot;Test Assert Strict Equals&quot;, () =&gt; {
  assertStrictEquals(1, 1);
  assertStrictEquals(&quot;Hello&quot;, &quot;Hello&quot;);
  assertStrictEquals(true, true);
  assertStrictEquals(undefined, undefined);
});
</code></pre>
<p><code>assertStrictEquals()</code> 最好用于精确判断两个基本类型的相等性。</p>
<h3><a class="header" href="#包含" id="包含">包含</a></h3>
<p><code>assertStringContains()</code> 和 <code>assertArrayContains()</code> 可用于断言包含关系。</p>
<p><code>assertStringContains()</code> 方法检查一个字符串是否包含了预期的字符串。</p>
<pre><code class="language-js">Deno.test(&quot;Test Assert String Contains&quot;, () =&gt; {
  assertStringContains(&quot;Hello World&quot;, &quot;Hello&quot;);
});
</code></pre>
<p><code>assertArrayContains()</code> 方法稍微高级一些，能够找到一个数组内的值，或是子数组。</p>
<pre><code class="language-js">Deno.test(&quot;Test Assert Array Contains&quot;, () =&gt; {
  assertArrayContains([1, 2, 3], [1]);
  assertArrayContains([1, 2, 3], [1, 2]);
  assertArrayContains(Array.from(&quot;Hello World&quot;), Array.from(&quot;Hello&quot;));
});
</code></pre>
<h3><a class="header" href="#正则表达式" id="正则表达式">正则表达式</a></h3>
<p>通过 <code>assertMatch()</code> 方法断言正则匹配。</p>
<pre><code class="language-js">Deno.test(&quot;Test Assert Match&quot;, () =&gt; {
  assertMatch(&quot;abcdefghi&quot;, new RegExp(&quot;def&quot;));

  const basicUrl = new RegExp(&quot;^https?://[a-z.]+.com$&quot;);
  assertMatch(&quot;https://www.google.com&quot;, basicUrl);
  assertMatch(&quot;http://facebook.com&quot;, basicUrl);
});
</code></pre>
<h3><a class="header" href="#抛出错误" id="抛出错误">抛出错误</a></h3>
<p>在 Deno 中有两种方式断言抛出错误的行为：<code>assertThrows()</code> 和 <code>assertAsyncThrows()</code>。</p>
<p>两种方式都能检查抛出<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error">错误</a> 的类型和信息。</p>
<p>两种方式的区别是 <code>assertThrows()</code> 接收一个标准函数，而 <code>assertAsyncThrows()</code> 接收一个返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> 的函数。</p>
<p><code>assertThrows()</code> 将检查抛出的错误，也可以检查所抛出的错误的类型是否正确，并判断错误消息是否符合预期。</p>
<pre><code class="language-js">Deno.test(&quot;Test Assert Throws&quot;, () =&gt; {
  assertThrows(
    () =&gt; {
      throw new Error(&quot;Panic!&quot;);
    },
    Error,
    &quot;Panic!&quot;,
  );
});
</code></pre>
<p><code>assertAsyncThrows()</code> 稍微复杂一点，主要是因为它处理 Promise。它将捕获 Promise 中抛出的错误或 rejection。您还可以选择检查错误类型和错误消息。</p>
<pre><code class="language-js">Deno.test(&quot;Test Assert Throws Async&quot;, () =&gt; {
  assertThrowsAsync(
    () =&gt; {
      return new Promise(() =&gt; {
        throw new Error(&quot;Panic! Threw Error&quot;);
      });
    },
    Error,
    &quot;Panic! Threw Error&quot;,
  );

  assertThrowsAsync(
    () =&gt; {
      return Promise.reject(new Error(&quot;Panic! Reject Error&quot;));
    },
    Error,
    &quot;Panic! Reject Error&quot;,
  );
});
</code></pre>
<h3><a class="header" href="#自定义消息" id="自定义消息">自定义消息</a></h3>
<p>Deno 的每个内置断言都允许您覆盖标准 CLI 错误消息。</p>
<p>这个示例将输出 &quot;Values Don't Match!&quot;，而不是标准 CLI 错误消息。</p>
<pre><code class="language-js">Deno.test(&quot;Test Assert Equal Fail Custom Message&quot;, () =&gt; {
  assertEquals(1, 2, &quot;Values Don't Match!&quot;);
});
</code></pre>
<h1><a class="header" href="#内置工具" id="内置工具">内置工具</a></h1>
<p>Deno 提供了一些内置的工具，在处理 JavaScript 和 TypeScript 时很有用。</p>
<ul>
<li><a href="./tools/bundler.html">打包器 (<code>deno bundle</code>)</a></li>
<li><a href="./tools/debugger.html">调试器 (<code>--inspect, --inspect-brk</code>)</a></li>
<li><a href="./tools/dependency_inspector.html">依赖检查器 (<code>deno info</code>)</a></li>
<li><a href="./tools/documentation_generator.html">文档生成器 (<code>deno doc</code>)</a></li>
<li><a href="./tools/formatter.html">代码格式化 (<code>deno fmt</code>)</a></li>
<li><a href="./testing.html">测试 (<code>deno test</code>)</a></li>
<li><a href="./tools/linter.html">linter (<code>deno lint</code>)</a></li>
</ul>
<h2><a class="header" href="#调试器-debugger" id="调试器-debugger">调试器 (debugger)</a></h2>
<p>Deno 支持 <a href="https://v8.dev/docs/inspector">V8 Inspector Protocol</a>.</p>
<p>使用 Chrome Devtools 或其他支持该协议的客户端（比如 VSCode）能够调试 Deno 程序。</p>
<p>要启用调试功能，用 <code>--inspect</code> 或 <code>--inspect-brk</code> 选项运行 Deno。</p>
<p><code>--inspect</code> 选项允许在任何时间点连接调试器，而 <code>--inspect-brk</code> 选项会等待调试器连接，在第一行代码处暂停执行。</p>
<h3><a class="header" href="#chrome-devtools" id="chrome-devtools">Chrome Devtools</a></h3>
<p>让我们用 Chrome 开发者工具来调试一个程序，我们将使用来自 <code>std</code> 的 <a href="https://deno.land/std@v0.50.0/http/file_server.ts">file_server.ts</a>，这是一个静态文件服务。</p>
<p>使用 <code>--inspect-brk</code> 选项，在第一行代码处暂停执行。</p>
<pre><code class="language-shell">$ deno run --inspect-brk --allow-read --allow-net https://deno.land/std@v0.50.0/http/file_server.ts
Debugger listening on ws://127.0.0.1:9229/ws/1e82c406-85a9-44ab-86b6-7341583480b1
Download https://deno.land/std@v0.50.0/http/file_server.ts
Compile https://deno.land/std@v0.50.0/http/file_server.ts
...
</code></pre>
<p>打开 <code>chrome://inspect</code>，点击 target 旁边的 <code>Inspect</code>。</p>
<p><img src="tools/../images/debugger1.jpg" alt="chrome://inspect" /></p>
<p>开发者工具加载所有模块时可能会等待几秒。</p>
<p><img src="tools/../images/debugger2.jpg" alt="Devtools opened" /></p>
<p>您可能注意到开发者工具暂停执行的地方不是 <code>file_server.ts</code>，而是 <code>_constants.ts</code> 的第一行。这是符合预期的行为，ES 模块在 V8 中执行的顺序如此。<code>_constants.ts</code> 是 <code>file_server.ts</code> 最深、最先的依赖，因此它会最先执行。</p>
<p>在这时，所有源码在开发者工具中都可用。打开 <code>file_server.ts</code>，加一处断点，然后打开 &quot;Sources&quot; 面板，展开树：</p>
<p><img src="tools/../images/debugger3.jpg" alt="Open file_server.ts" /></p>
<p><em>仔细观察，您会发现每个文件都有重复的条目，一个是正常字体，另一个是斜体。前者是编译后的源文件（所以 <code>.ts</code> 文件会生成 JavaScript 源代码），后者是该文件的源映射 (source map)。</em></p>
<p>下一步，在 <code>listenAndServe</code> 方法处加一个断点。</p>
<p><img src="tools/../images/debugger4.jpg" alt="Break in file_server.ts" /></p>
<p>添加断点后，开发者工具会自动打开源映射文件，让我们能在包含类型的实际源码中步进。</p>
<p>现在我们已经设置了断点，在触发断点时，我们可以检查传入的请求，也可以继续执行脚本。点击恢复脚本执行的按钮即可，您可能需要点两次。</p>
<p>当脚本继续运行时，让我们发送一个请求，看看开发者工具中发生了什么。</p>
<pre><code>$ curl http://0.0.0.0:4500/
</code></pre>
<p><img src="tools/../images/debugger5.jpg" alt="Break in request handling" /></p>
<p>在这时，我们可以检查请求的内容，逐步调试代码。</p>
<h3><a class="header" href="#vscode" id="vscode">VSCode</a></h3>
<p>Deno 可以在 VSCode 中调试。</p>
<p>插件的官方支持正在开发中 <a href="https://github.com/denoland/vscode_deno/issues/12">https://github.com/denoland/vscode_deno/issues/12</a></p>
<p>我们也可以通过手动提供 <a href="https://code.visualstudio.com/docs/editor/debugging#_launch-configurations"><code>launch.json</code></a> 配置，来连接调试器：</p>
<pre><code class="language-json">{
  &quot;version&quot;: &quot;0.2.0&quot;,
  &quot;configurations&quot;: [
    {
      &quot;name&quot;: &quot;Deno&quot;,
      &quot;type&quot;: &quot;node&quot;,
      &quot;request&quot;: &quot;launch&quot;,
      &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
      &quot;runtimeExecutable&quot;: &quot;deno&quot;,
      &quot;runtimeArgs&quot;: [&quot;run&quot;, &quot;--inspect-brk&quot;, &quot;-A&quot;, &quot;${file}&quot;],
      &quot;port&quot;: 9229
    }
  ]
}
</code></pre>
<p><strong>注意</strong>：这将使用您打开的文件作为入口点；如果需要固定的入口点，请用脚本名称替换 <code>${file}</code>。</p>
<p>让我们尝试一下本地源文件，创建 <code>server.ts</code>：</p>
<pre><code class="language-ts">import { serve } from &quot;https://deno.land/std@v0.50.0/http/server.ts&quot;;
const server = serve({ port: 8000 });
console.log(&quot;http://localhost:8000/&quot;);

for await (const req of server) {
  req.respond({ body: &quot;Hello World\n&quot; });
}
</code></pre>
<p>然后我们可以设置断点，运行已创建的配置：</p>
<p><img src="tools/../images/debugger7.jpg" alt="VSCode debugger" /></p>
<h3><a class="header" href="#jetbrains-ide-1" id="jetbrains-ide-1">JetBrains IDE</a></h3>
<p>您可以使用 JetBrains IDE 来调试 Deno，右击您想要调试的文件，选择 <code>Debug 'Deno: &lt;file name&gt;'</code>。这会创建一个没有权限设置的 运行/调试 配置，您可能需要更改 <code>Arguments</code> 字段来提供所需权限。</p>
<h3><a class="header" href="#其他" id="其他">其他</a></h3>
<p>实现 Devtools 协议的任何客户端都能连接 Deno 进程。</p>
<h3><a class="header" href="#限制" id="限制">限制</a></h3>
<p>开发者工具的支持仍不成熟，有一些功能是缺失的，或是有 bug 的：</p>
<ul>
<li>开发者工具控制台中的自动补全会让 Deno 进程退出。</li>
<li>性能分析 (profiling) 和内存转储 (memory dump) 可能不正确。</li>
</ul>
<h2><a class="header" href="#脚本安装器" id="脚本安装器">脚本安装器</a></h2>
<p>Deno 提供 <code>deno install</code> 来安装和分发可执行代码。</p>
<p><code>deno install [OPTIONS...] [URL] [SCRIPT_ARGS...]</code> 将把位于 <code>URL</code> 的脚本安装到名称 <code>EXE_NAME</code> 下。</p>
<p>这个命令将会创建一个轻薄的 shell 脚本来调用 <code>deno</code>，其中写入了特定的命令行参数。它位于 <code>deno</code> 安装目录的 <code>bin</code> 子目录下。</p>
<p>示例：</p>
<pre><code class="language-shell">$ deno install --allow-net --allow-read https://deno.land/std/http/file_server.ts
[1/1] Compiling https://deno.land/std/http/file_server.ts

✅ Successfully installed file_server.
/Users/deno/.deno/bin/file_server
</code></pre>
<p>要改变命令名称，使用 <code>-n</code>/<code>--name</code> 参数：</p>
<pre><code class="language-shell">deno install --allow-net --allow-read -n serve https://deno.land/std/http/file_server.ts
</code></pre>
<p>默认情况下，Deno 会自动推导命令名称。</p>
<ul>
<li>
<p>尝试获取文件名称 (file stem)，以上示例将推导为 &quot;file_server&quot;</p>
</li>
<li>
<p>如果文件名称是通用的，比如 &quot;main&quot;、&quot;mod&quot;、&quot;index&quot; 或 &quot;cli&quot;，并且它的路径没有父级，那么取父级路径的文件名，否则设置为原通用名称。</p>
</li>
</ul>
<p>要改变安装路径，使用 <code>--root</code> 选项：</p>
<pre><code class="language-shell">deno install --allow-net --allow-read --root /usr/local https://deno.land/std/http/file_server.ts
</code></pre>
<p>按照优先顺序确定安装根目录：</p>
<ul>
<li><code>--root</code> 选项</li>
<li><code>DENO_INSTALL_ROOT</code> 环境变量</li>
<li><code>$HOME/.deno</code></li>
</ul>
<p>如果需要，它们必须被添加进 <code>PATH</code> 环境变量。</p>
<pre><code class="language-shell">echo 'export PATH=&quot;$HOME/.deno/bin:$PATH&quot;' &gt;&gt; ~/.bashrc
</code></pre>
<p>在安装时，您必须指定脚本会用到的权限。</p>
<pre><code class="language-shell">deno install --allow-net --allow-read https://deno.land/std/http/file_server.ts 8080
</code></pre>
<p>以上命令会创建一个名叫 <code>file_server</code> 的命令，运行时需要读取权限和网络权限，绑定到 8080 端口。</p>
<p>我们建议使用 <a href="tools/../examples/testing_if_main.html">import.meta.main</a> 来指定作为可执行脚本时的入口点。</p>
<p>示例：</p>
<!-- dprint-ignore -->
<pre><code class="language-ts">// https://example.com/awesome/cli.ts
async function myAwesomeCli(): Promise&lt;void&gt; {
  -- snip --
}

if (import.meta.main) {
  myAwesomeCli();
}
</code></pre>
<p>当您创建一个可执行脚本时，最好在仓库中告诉用户如何安装，让用户看到一个示例安装命令。</p>
<pre><code class="language-shell"># 使用 deno install 安装

$ deno install -n awesome_cli https://example.com/awesome/cli.ts
</code></pre>
<h2><a class="header" href="#代码格式化" id="代码格式化">代码格式化</a></h2>
<p>Deno 有着内置的格式化工具，能够格式化 TypeScript 和 JavaScript 代码。</p>
<pre><code class="language-shell"># 格式化当前目录和子目录下的所有 JS/TS 文件
deno fmt
# 格式化特定的文件
deno fmt myfile1.ts myfile2.ts
# 检查当前目录和子目录下的所有 JS/TS 文件是否都已被格式化
deno fmt --check
# 将标准输入流格式化并写入标准输出流
cat file.ts | deno fmt -
</code></pre>
<p>通过加上一句 <code>// deno-fmt-ignore</code> 注释来忽略格式化。</p>
<pre><code class="language-ts">// deno-fmt-ignore
export const identity = [
    1, 0, 0,
    0, 1, 0,
    0, 0, 1,
];
</code></pre>
<p>在文件头部加上一句 <code>// deno-fmt-ignore-file</code> 注释可以忽略整个文件。</p>
<h2><a class="header" href="#打包" id="打包">打包</a></h2>
<p><code>deno bundle [URL]</code> 将输出一个单独的 JavaScript 文件，其中包含了它的所有依赖。</p>
<p>示例：</p>
<pre><code>&gt; deno bundle https://deno.land/std/examples/colors.ts colors.bundle.js
Bundling &quot;colors.bundle.js&quot;
Emitting bundle to &quot;colors.bundle.js&quot;
9.2 kB emitted.
</code></pre>
<p>如果您忽略了输出文件参数，打包文件将输出到 stdout。</p>
<p>这个打包文件能够像其他任何模块一样在 Deno 中运行。</p>
<pre><code>deno run colors.bundle.js
</code></pre>
<p>打包文件是一个自包含 (self contained) 的 ES 模块，其中的任何导出仍然可用。</p>
<p>举个例子，如果主模块是这样的：</p>
<pre><code class="language-ts">export { foo } from &quot;./foo.js&quot;;

export const bar = &quot;bar&quot;;
</code></pre>
<p>它可以像这样被导入：</p>
<pre><code class="language-ts">import { foo, bar } from &quot;./lib.bundle.js&quot;;
</code></pre>
<p>打包文件也可以在浏览器中被加载，它是一个自包含的 ES 模块，因此 <code>type</code> 属性 (attribute) 必须设置为 <code>&quot;module&quot;</code>。</p>
<p>示例：</p>
<pre><code class="language-html">&lt;script type=&quot;module&quot; src=&quot;website.bundle.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>除了直接加载，它也可以从其他模块导入。</p>
<pre><code class="language-html">&lt;script type=&quot;module&quot;&gt;
  import * as website from &quot;website.bundle.js&quot;;
&lt;/script&gt;
</code></pre>
<h2><a class="header" href="#文档生成器" id="文档生成器">文档生成器</a></h2>
<p><code>deno doc</code> 将处理一个或一组源文件，为每个模块的<strong>导出</strong>成员打印出 JSDoc 文档。</p>
<p>目前只支持两种导出声明：</p>
<ul>
<li><code>export &lt;declaration&gt;</code></li>
<li><code>export ... from ...</code></li>
</ul>
<p>例如，对于这样的一个文件 <code>add.ts</code>：</p>
<pre><code class="language-ts">/**
 * Adds x and y.
 * @param {number} x
 * @param {number} y
 * @returns {number} Sum of x and y
 */
export function add(x: number, y: number): number {
  return x + y;
}
</code></pre>
<p>运行 Deno <code>doc</code> 命令，把该函数的 JSDoc 注释打印到 <code>stdout</code>：</p>
<pre><code class="language-shell">deno doc add.ts
function add(x: number, y: number): number
  Adds x and y. @param {number} x @param {number} y @returns {number} Sum of x and y
</code></pre>
<p>使用 <code>--json</code> 选项，用 JSON 格式输出文档。该格式在 <a href="https://github.com/denoland/doc_website">deno doc website</a> 使用，用以生成模块文档。</p>
<h2><a class="header" href="#依赖检查器" id="依赖检查器">依赖检查器</a></h2>
<p><code>deno info [URL]</code> 会列出 ES 模块和它的所有依赖。</p>
<pre><code class="language-shell">deno info https://deno.land/std@0.52.0/http/file_server.ts
Download https://deno.land/std@0.52.0/http/file_server.ts
...
local: /Users/deno/Library/Caches/deno/deps/https/deno.land/5bd138988e9d20db1a436666628ffb3f7586934e0a2a9fe2a7b7bf4fb7f70b98
type: TypeScript
compiled: /Users/deno/Library/Caches/deno/gen/https/deno.land/std@0.52.0/http/file_server.ts.js
map: /Users/deno/Library/Caches/deno/gen/https/deno.land/std@0.52.0/http/file_server.ts.js.map
deps:
https://deno.land/std@0.52.0/http/file_server.ts
  ├─┬ https://deno.land/std@0.52.0/path/mod.ts
  │ ├─┬ https://deno.land/std@0.52.0/path/win32.ts
  │ │ ├── https://deno.land/std@0.52.0/path/_constants.ts
  │ │ ├─┬ https://deno.land/std@0.52.0/path/_util.ts
  │ │ │ └── https://deno.land/std@0.52.0/path/_constants.ts
  │ │ └─┬ https://deno.land/std@0.52.0/testing/asserts.ts
  │ │   ├── https://deno.land/std@0.52.0/fmt/colors.ts
  │ │   └── https://deno.land/std@0.52.0/testing/diff.ts
  │ ├─┬ https://deno.land/std@0.52.0/path/posix.ts
  │ │ ├── https://deno.land/std@0.52.0/path/_constants.ts
  │ │ └── https://deno.land/std@0.52.0/path/_util.ts
  │ ├─┬ https://deno.land/std@0.52.0/path/common.ts
  │ │ └── https://deno.land/std@0.52.0/path/separator.ts
  │ ├── https://deno.land/std@0.52.0/path/separator.ts
  │ ├── https://deno.land/std@0.52.0/path/interface.ts
  │ └─┬ https://deno.land/std@0.52.0/path/glob.ts
  │   ├── https://deno.land/std@0.52.0/path/separator.ts
  │   ├── https://deno.land/std@0.52.0/path/_globrex.ts
  │   ├── https://deno.land/std@0.52.0/path/mod.ts
  │   └── https://deno.land/std@0.52.0/testing/asserts.ts
  ├─┬ https://deno.land/std@0.52.0/http/server.ts
  │ ├── https://deno.land/std@0.52.0/encoding/utf8.ts
  │ ├─┬ https://deno.land/std@0.52.0/io/bufio.ts
  │ │ ├─┬ https://deno.land/std@0.52.0/io/util.ts
  │ │ │ ├── https://deno.land/std@0.52.0/path/mod.ts
  │ │ │ └── https://deno.land/std@0.52.0/encoding/utf8.ts
  │ │ └── https://deno.land/std@0.52.0/testing/asserts.ts
  │ ├── https://deno.land/std@0.52.0/testing/asserts.ts
  │ ├─┬ https://deno.land/std@0.52.0/async/mod.ts
  │ │ ├── https://deno.land/std@0.52.0/async/deferred.ts
  │ │ ├── https://deno.land/std@0.52.0/async/delay.ts
  │ │ └─┬ https://deno.land/std@0.52.0/async/mux_async_iterator.ts
  │ │   └── https://deno.land/std@0.52.0/async/deferred.ts
  │ └─┬ https://deno.land/std@0.52.0/http/_io.ts
  │   ├── https://deno.land/std@0.52.0/io/bufio.ts
  │   ├─┬ https://deno.land/std@0.52.0/textproto/mod.ts
  │   │ ├── https://deno.land/std@0.52.0/io/util.ts
  │   │ ├─┬ https://deno.land/std@0.52.0/bytes/mod.ts
  │   │ │ └── https://deno.land/std@0.52.0/io/util.ts
  │   │ └── https://deno.land/std@0.52.0/encoding/utf8.ts
  │   ├── https://deno.land/std@0.52.0/testing/asserts.ts
  │   ├── https://deno.land/std@0.52.0/encoding/utf8.ts
  │   ├── https://deno.land/std@0.52.0/http/server.ts
  │   └── https://deno.land/std@0.52.0/http/http_status.ts
  ├─┬ https://deno.land/std@0.52.0/flags/mod.ts
  │ └── https://deno.land/std@0.52.0/testing/asserts.ts
  └── https://deno.land/std@0.52.0/testing/asserts.ts
</code></pre>
<p>依赖检查器对本地或远程的任意 ES 模块都有效。</p>
<h2><a class="header" href="#缓存位置" id="缓存位置">缓存位置</a></h2>
<p><code>deno info</code> 可以用来显示与缓存位置有关的信息：</p>
<pre><code class="language-shell">deno info
DENO_DIR location: &quot;/Users/deno/Library/Caches/deno&quot;
Remote modules cache: &quot;/Users/deno/Library/Caches/deno/deps&quot;
TypeScript compiler cache: &quot;/Users/deno/Library/Caches/deno/gen&quot;
</code></pre>
<h2><a class="header" href="#linter" id="linter">Linter</a></h2>
<p>Deno 附带了 JavaScript 和 TypeScript 的内置 linter。</p>
<p><strong>注意：linter 是一个新功能，仍然不稳定，因此需要 <code>--unstable</code> 选项</strong></p>
<pre><code class="language-shell"># 检查当前目录树内所有 JS/TS 文件
deno lint --unstable
# 检查特定文件
deno lint --unstable myfile1.ts myfile2.ts
</code></pre>
<h3><a class="header" href="#可用规则" id="可用规则">可用规则</a></h3>
<ul>
<li><code>ban-ts-comment</code></li>
<li><code>ban-untagged-ignore</code></li>
<li><code>constructor-super</code></li>
<li><code>for-direction</code></li>
<li><code>getter-return</code></li>
<li><code>no-array-constructor</code></li>
<li><code>no-async-promise-executor</code></li>
<li><code>no-case-declarations</code></li>
<li><code>no-class-assign</code></li>
<li><code>no-compare-neg-zero</code></li>
<li><code>no-cond-assign</code></li>
<li><code>no-debugger</code></li>
<li><code>no-delete-var</code></li>
<li><code>no-dupe-args</code></li>
<li><code>no-dupe-keys</code></li>
<li><code>no-duplicate-case</code></li>
<li><code>no-empty-character-class</code></li>
<li><code>no-empty-interface</code></li>
<li><code>no-empty-pattern</code></li>
<li><code>no-empty</code></li>
<li><code>no-ex-assign</code></li>
<li><code>no-explicit-any</code></li>
<li><code>no-func-assign</code></li>
<li><code>no-misused-new</code></li>
<li><code>no-namespace</code></li>
<li><code>no-new-symbol</code></li>
<li><code>no-obj-call</code></li>
<li><code>no-octal</code></li>
<li><code>no-prototype-builtins</code></li>
<li><code>no-regex-spaces</code></li>
<li><code>no-setter-return</code></li>
<li><code>no-this-alias</code></li>
<li><code>no-this-before-super</code></li>
<li><code>no-unsafe-finally</code></li>
<li><code>no-unsafe-negation</code></li>
<li><code>no-with</code></li>
<li><code>prefer-as-const</code></li>
<li><code>prefer-namespace-keyword</code></li>
<li><code>require-yield</code></li>
<li><code>triple-slash-reference</code></li>
<li><code>use-isnan</code></li>
<li><code>valid-typeof</code></li>
</ul>
<h3><a class="header" href="#忽略指令" id="忽略指令">忽略指令</a></h3>
<h4><a class="header" href="#文件" id="文件">文件</a></h4>
<p>要忽略整个文件，<code>// deno-lint-ignore-file</code> 指令应该置于文件顶部。</p>
<pre><code class="language-ts">// deno-lint-ignore-file

function foo(): any {
  // ...
}
</code></pre>
<p>必须在第一个语句或声明之前放置忽略指令：</p>
<pre><code class="language-ts">// Copyright 2020 the Deno authors. All rights reserved. MIT license.

/**
 * Some JS doc
 **/

// deno-lint-ignore-file

import { bar } from &quot;./bar.js&quot;;

function foo(): any {
  // ...
}
</code></pre>
<h4><a class="header" href="#诊断-diagnostics" id="诊断-diagnostics">诊断 (Diagnostics)</a></h4>
<p>要忽略某些诊断，<code>// deno-lint-ignore &lt;codes ...&gt;</code> 指令应该置于违规行之前。必须指定要忽略的规则名称。</p>
<pre><code class="language-ts">// deno-lint-ignore no-explicit-any
function foo(): any {
  // ...
}

// deno-lint-ignore no-explicit-any explicit-function-return-type
function bar(a: any) {
  // ...
}
</code></pre>
<p>为了与 ESLint 兼容，<code>deno lint</code> 也支持 <code>// eslint-ignore-next-line</code> 指令。像 <code>// deno-lint-ignore</code> 一样，这也需要指定忽略的规则名称。</p>
<pre><code class="language-ts">// eslint-ignore-next-line no-empty
while (true) {}

// eslint-ignore-next-line @typescript-eslint/no-explicit-any
function bar(a: any) {
  // ...
}
</code></pre>
<h1><a class="header" href="#嵌入式-deno" id="嵌入式-deno">嵌入式 Deno</a></h1>
<p>Deno 由多个部分组成，其中之一是 <code>deno_core</code>。这是一个 rust
crate，可以用作 Rust 应用中的嵌入式 JavaScript 运行时。</p>
<p>Deno 建立在 <code>deno_core</code> 的基础上。</p>
<p>Deno crate 发布于 <a href="https://crates.io/crates/deno_core">crates.io</a>。</p>
<p>您可以通过 <a href="https://docs.rs/deno_core">docs.rs</a> 查阅其 API。</p>
<!-- TODO(lucacasonato): better docs -->
<h1><a class="header" href="#贡献" id="贡献">贡献</a></h1>
<ul>
<li>
<p>阅读 <a href="./style-guide.zh-CN.html">风格指南</a>.</p>
</li>
<li>
<p>请不要让 <a href="https://deno.land/benchmarks.html">性能测试</a> 变糟。</p>
</li>
<li>
<p>在 <a href="https://discord.gg/deno">社区聊天室</a> 获取帮助。</p>
</li>
<li>
<p>如果您将要在某个 issue 下做些工作，在那之前请先在 issue 中提示一下。</p>
</li>
<li>
<p>请在论坛上保持专业。我们遵循 Rust 的<a href="https://www.rust-lang.org/policies/code-of-conduct">行为准则</a> (Code of conduct)。有问题请向 ry 发邮件(ry@tinyclouds.org)。</p>
</li>
</ul>
<h2><a class="header" href="#开发" id="开发">开发</a></h2>
<p>从源码构建的步骤在 <a href="./contributing/building_from_source.html">这里</a></p>
<h2><a class="header" href="#发起一个-pull-request" id="发起一个-pull-request">发起一个 Pull Request</a></h2>
<p>在提交之前，请确认以下步骤：</p>
<ol>
<li>存在一个相关 issue，并且 PR 文本中引用了它。</li>
<li>有覆盖这些变化的测试。</li>
<li>确保 <code>cargo test</code> 通过。</li>
<li>使用 <code>./tools/format.py</code> 格式化代码。</li>
<li>确保 <code>./tools/lint.py</code> 通过。</li>
</ol>
<h2><a class="header" href="#third_party-的改动" id="third_party-的改动"><code>third_party</code> 的改动</a></h2>
<p><a href="https://github.com/denoland/deno_third_party"><code>deno_third_party</code></a> 包含了大部分 Deno 依赖的外部代码，所以我们在任何时候都知道我们在运行什么。我们用一些手动操作和私有脚本来维护它，要做出改动，您可能需要联系 @ry 或 @piscisaureus。</p>
<h2><a class="header" href="#增加-ops" id="增加-ops">增加 Ops</a></h2>
<p>Ops 又称“绑定” (bindings)。</p>
<p>我们非常担心在添加新 API 时会出错。在向 Deno 添加 Op 时，应该研究其他平台上的对应接口。请列出如何在 Go、Node、Rust 和 Python 中完成此功能。</p>
<p>例如，参考 <code>deno.rename()</code> 是如何在
<a href="https://github.com/denoland/deno/pull/671">PR #671</a> 中提出并添加的。</p>
<h2><a class="header" href="#发布" id="发布">发布</a></h2>
<p>以往发布的所做更改的总结在 <a href="https://github.com/denoland/deno/releases">这里</a>。</p>
<h2><a class="header" href="#api-文档" id="api-文档">API 文档</a></h2>
<p>公开 API 的文档很重要，我们希望它与代码内联。这有助于确保代码和文档紧密结合在一起。</p>
<h3><a class="header" href="#利用-jsdoc" id="利用-jsdoc">利用 JSDoc</a></h3>
<p>所有通过 <code>deno</code> 模块以及 global/<code>window</code> 命名空间公开的 API 和类型都应该有 JSDoc 文档。该文档经过解析并可供 TypeScript 编译器使用，因此易于在下游提供。JSDoc 块就在它们应用的语句之前，并以 <code>/** doc */</code> 表示。例如：</p>
<pre><code class="language-ts">/** A simple JSDoc comment */
export const FOO = &quot;foo&quot;;
</code></pre>
<p>更多信息位于 <a href="https://jsdoc.app/">https://jsdoc.app/</a></p>
<p>TODO</p>
<h2><a class="header" href="#从源码构建-1" id="从源码构建-1">从源码构建</a></h2>
<p>以下是从源码构建 Deno 的操作步骤。如果您只是想使用 Deno，您可以下载一个预构建的可执行文件，参考 <code>入门</code> 章节。</p>
<h3><a class="header" href="#克隆-deno-仓库" id="克隆-deno-仓库">克隆 Deno 仓库</a></h3>
<p>Linux 或 Mac 系统：</p>
<p>Clone on Linux or Mac:</p>
<pre><code class="language-shell">git clone --recurse-submodules https://github.com/denoland/deno.git
</code></pre>
<p>在 Windows 系统上有一些额外步骤：</p>
<ol>
<li>
<p>打开“<a href="https://www.google.com/search?q=windows+enable+developer+mode">开发者模式</a>”，否则符号链接将需要管理员权限。</p>
</li>
<li>
<p>确认您正在使用 git 2.19.2.windows.1 或更高版本。</p>
</li>
<li>
<p>在检出 (checkout) 前，设置 <code>core.symlinks=true</code>。</p>
<pre><code class="language-shell">git config --global core.symlinks true
git clone --recurse-submodules https://github.com/denoland/deno.git
</code></pre>
</li>
</ol>
<h3><a class="header" href="#前置条件" id="前置条件">前置条件</a></h3>
<p>您需要 <a href="https://www.rust-lang.org/tools/install">安装 Rust</a>。Deno 不支持每晚版本(nightly) 构建，请确定您获取的是最新的稳定版本(stable release)。</p>
<p>检查以下工具是否已经安装：</p>
<pre><code>rustc -V
cargo -V
</code></pre>
<h3><a class="header" href="#设置-rust-的编译目标和组件" id="设置-rust-的编译目标和组件">设置 rust 的编译目标和组件</a></h3>
<pre><code class="language-shell">rustup target add wasm32-unknown-unknown
rustup target add wasm32-wasi
</code></pre>
<h3><a class="header" href="#构建-deno" id="构建-deno">构建 Deno</a></h3>
<p>最简单的方式是使用预编译的 V8 ：</p>
<pre><code>cargo build -vv
</code></pre>
<p>如果您想要从源码构建 Deno 和 V8 ：</p>
<pre><code>V8_FROM_SOURCE=1 cargo build -vv
</code></pre>
<p>从源码构建 V8 时会有更多依赖：</p>
<p><a href="https://www.python.org/downloads">Python 2</a>. 确认您的 <code>PATH</code> 环境变量中有一个无后缀 (suffix-less) 的 <code>python</code>/<code>python.exe</code>，并且它指向 Python 2，而不是 Python3 (<a href="https://github.com/denoland/deno/issues/464#issuecomment-411795578">issue 464</a>)。</p>
<p>Linux 用户：必须已经安装 glib-2.0 开发文件。（在 Ubuntu 上，运行 <code>apt install libglib2.0-dev</code>）</p>
<p>Mac 用户：必须已经安装 Command Line Tools。（<a href="https://developer.apple.com/xcode/">XCode</a> 已经包含了 CLT。运行 <code>xcode-select --install</code> 来在没有 XCode 的情况下安装它。）</p>
<p>Windows 用户：</p>
<ol>
<li>
<p>安装 <a href="https://www.visualstudio.com/downloads/">VS Community 2019</a>，安装 &quot;Desktop development with C++&quot; 工具包，确认以下工具都已被选中和安装。</p>
<ul>
<li>Visual C++ tools for CMake</li>
<li>Windows 10 SDK (10.0.17763.0)</li>
<li>Testing tools core features - Build Tools</li>
<li>Visual C++ ATL for x86 and x64</li>
<li>Visual C++ MFC for x86 and x64</li>
<li>C++/CLI support</li>
<li>VC++ 2015.3 v14.00 (v140) toolset for desktop</li>
</ul>
</li>
</ol>
<ol start="2">
<li>启用 &quot;Debugging Tools for Windows&quot;：
&quot;Control Panel&quot;
→ &quot;Programs&quot;
→ &quot;Programs and Features&quot;
→ 选择 &quot;Windows Software Development Kit - Windows 10&quot;
→ &quot;Change&quot;
→ &quot;Change&quot;
→ 检查 &quot;Debugging Tools For Windows&quot;
→ &quot;Change&quot;
→ &quot;Finish&quot;
或者使用 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/">Debugging Tools for Windows</a>，它会下载文件，您应该手动安装 <code>X64 Debuggers And Tools-x64_en-us.msi</code>。</li>
</ol>
<p>有关构建 V8 的更多细节请查阅 <a href="https://github.com/denoland/rusty_v8">rusty_v8's README</a></p>
<h3><a class="header" href="#构建" id="构建">构建</a></h3>
<p>使用 Cargo：</p>
<pre><code class="language-shell"># 构建：
cargo build -vv

# 构建失败？确保您位于最新的 master 分支，然后再试一次。如果还不行，尝试清除上一次的结果：
cargo clean &amp;&amp; cargo build -vv

# 运行：
./target/debug/deno run cli/tests/002_hello.ts
</code></pre>
<p>TODO</p>
<h2><a class="header" href="#测试和工具" id="测试和工具">测试和工具</a></h2>
<h3><a class="header" href="#测试-1" id="测试-1">测试</a></h3>
<p>测试 <code>deno</code>:</p>
<pre><code class="language-shell"># 运行所有测试套件：
cargo test

# 只测试 cli/js/：
cargo test js_unit_tests
</code></pre>
<p>测试 <code>std/</code>:</p>
<pre><code class="language-shell">cargo test std_tests
</code></pre>
<h3><a class="header" href="#代码检查与格式化" id="代码检查与格式化">代码检查与格式化</a></h3>
<p>检查</p>
<pre><code class="language-shell">./tools/lint.py
</code></pre>
<p>格式化</p>
<pre><code class="language-shell">./tools/format.py
</code></pre>
<h3><a class="header" href="#性能分析" id="性能分析">性能分析</a></h3>
<pre><code class="language-sh"># 确认我们正在构建发布版 (release)。
# 构建 deno 和 V8 的 d8。
ninja -C target/release d8

# 使用 --prof 选项运行想要分析的程序。
./target/release/deno run tests/http_bench.ts --allow-net --v8-flags=--prof &amp;

# 施加压力。
third_party/wrk/linux/wrk http://localhost:4500/
kill `pgrep deno`
</code></pre>
<p>V8 将在当前目录写入一个文件，像这样 <code>isolate-0x7fad98242400-v8.log</code>。查看这个文件：</p>
<pre><code class="language-sh">D8_PATH=target/release/ ./third_party/v8/tools/linux-tick-processor
isolate-0x7fad98242400-v8.log &gt; prof.log
# 在 macOS 上, 使用 ./third_party/v8/tools/mac-tick-processor
</code></pre>
<p><code>prof.log</code> 将包含不用调用的 tick 分布。</p>
<p>用 Web UI 查看这个日志，先生成 JSON 文件：</p>
<pre><code class="language-sh">D8_PATH=target/release/ ./third_party/v8/tools/linux-tick-processor
isolate-0x7fad98242400-v8.log --preprocess &gt; prof.json
</code></pre>
<p>在您的浏览器中打开 <code>third_party/v8/tools/profview/index.html</code>，选择 <code>prof.json</code> 以查看分布图。</p>
<p>在性能分析时有用的 V8 选项：</p>
<ul>
<li>--prof</li>
<li>--log-internal-timer-events</li>
<li>--log-timer-events</li>
<li>--track-gc</li>
<li>--log-source-code</li>
<li>--track-gc-object-stats</li>
</ul>
<p>有关 <code>d8</code> 和性能分析的更多信息，请查阅以下链接：</p>
<ul>
<li><a href="https://v8.dev/docs/d8">https://v8.dev/docs/d8</a></li>
<li><a href="https://v8.dev/docs/profile">https://v8.dev/docs/profile</a></li>
</ul>
<h3><a class="header" href="#使用-lldb-调试" id="使用-lldb-调试">使用 LLDB 调试</a></h3>
<h3><a class="header" href="#debugging-with-lldb" id="debugging-with-lldb">Debugging with LLDB</a></h3>
<pre><code class="language-shell">$ lldb -- target/debug/deno run tests/worker.js
&gt; run
&gt; bt
&gt; up
&gt; up
&gt; l
</code></pre>
<p>调试 Rust 代码，可以用 <code>rust-lldb</code>。</p>
<pre><code class="language-shell">$ rust-lldb -- ./target/debug/deno run --allow-net tests/http_bench.ts
# 在 macOS 上，您可能看到像这样的警告：
# `ImportError: cannot import name _remove_dead_weakref`
# 在这种情况下，设置 PATH 以使用系统 python，例如
# PATH=/System/Library/Frameworks/Python.framework/Versions/2.7/bin:$PATH
(lldb) command script import &quot;/Users/kevinqian/.rustup/toolchains/1.36.0-x86_64-apple-darwin/lib/rustlib/etc/lldb_rust_formatters.py&quot;
(lldb) type summary add --no-value --python-function lldb_rust_formatters.print_val -x &quot;.*&quot; --category Rust
(lldb) type category enable Rust
(lldb) target create &quot;../deno/target/debug/deno&quot;
Current executable set to '../deno/target/debug/deno' (x86_64).
(lldb) settings set -- target.run-args  &quot;tests/http_bench.ts&quot; &quot;--allow-net&quot;
(lldb) b op_start
(lldb) r
</code></pre>
<h3><a class="header" href="#v8-选项" id="v8-选项">V8 选项</a></h3>
<p>V8 有很多内部的命令行选项。</p>
<pre><code class="language-shell">$ deno run --v8-flags=--help _
SSE3=1 SSSE3=1 SSE4_1=1 SSE4_2=1 SAHF=1 AVX=1 FMA3=1 BMI1=1 BMI2=1 LZCNT=1 POPCNT=1 ATOM=0
Synopsis:
  shell [options] [--shell] [&lt;file&gt;...]
  d8 [options] [-e &lt;string&gt;] [--shell] [[--module] &lt;file&gt;...]

  -e        execute a string in V8
  --shell   run an interactive JavaScript shell
  --module  execute a file as a JavaScript module

Note: the --module option is implicitly enabled for *.mjs files.

The following syntax for options is accepted (both '-' and '--' are ok):
  --flag        (bool flags only)
  --no-flag     (bool flags only)
  --flag=value  (non-bool flags only, no spaces around '=')
  --flag value  (non-bool flags only)
  --            (captures all remaining args in JavaScript)

Options:
  --use-strict (enforce strict mode)
        type: bool  default: false
  --es-staging (enable test-worthy harmony features (for internal use only))
        type: bool  default: false
  --harmony (enable all completed harmony features)
        type: bool  default: false
  --harmony-shipping (enable all shipped harmony features)
        type: bool  default: true
  --harmony-regexp-sequence (enable &quot;RegExp Unicode sequence properties&quot; (in progress))
        type: bool  default: false
  --harmony-weak-refs-with-cleanup-some (enable &quot;harmony weak references with FinalizationRegistry.prototype.cleanupSome&quot; (in progress))
        type: bool  default: false
  --harmony-regexp-match-indices (enable &quot;harmony regexp match indices&quot; (in progress))
        type: bool  default: false
  --harmony-top-level-await (enable &quot;harmony top level await&quot;)
        type: bool  default: false
  --harmony-namespace-exports (enable &quot;harmony namespace exports (export * as foo from 'bar')&quot;)
        type: bool  default: true
  --harmony-sharedarraybuffer (enable &quot;harmony sharedarraybuffer&quot;)
        type: bool  default: true
  --harmony-import-meta (enable &quot;harmony import.meta property&quot;)
        type: bool  default: true
  --harmony-dynamic-import (enable &quot;harmony dynamic import&quot;)
        type: bool  default: true
  --harmony-promise-all-settled (enable &quot;harmony Promise.allSettled&quot;)
        type: bool  default: true
  --harmony-promise-any (enable &quot;harmony Promise.any&quot;)
        type: bool  default: true
  --harmony-private-methods (enable &quot;harmony private methods in class literals&quot;)
        type: bool  default: true
  --harmony-weak-refs (enable &quot;harmony weak references&quot;)
        type: bool  default: true
  --harmony-string-replaceall (enable &quot;harmony String.prototype.replaceAll&quot;)
        type: bool  default: true
  --harmony-logical-assignment (enable &quot;harmony logical assignment&quot;)
        type: bool  default: true
  --lite-mode (enables trade-off of performance for memory savings)
        type: bool  default: false
  --future (Implies all staged features that we want to ship in the not-too-far future)
        type: bool  default: false
  --assert-types (generate runtime type assertions to test the typer)
        type: bool  default: false
  --allocation-site-pretenuring (pretenure with allocation sites)
        type: bool  default: true
  --page-promotion (promote pages based on utilization)
        type: bool  default: true
  --always-promote-young-mc (always promote young objects during mark-compact)
        type: bool  default: true
  --page-promotion-threshold (min percentage of live bytes on a page to enable fast evacuation)
        type: int  default: 70
  --trace-pretenuring (trace pretenuring decisions of HAllocate instructions)
        type: bool  default: false
  --trace-pretenuring-statistics (trace allocation site pretenuring statistics)
        type: bool  default: false
  --track-fields (track fields with only smi values)
        type: bool  default: true
  --track-double-fields (track fields with double values)
        type: bool  default: true
  --track-heap-object-fields (track fields with heap values)
        type: bool  default: true
  --track-computed-fields (track computed boilerplate fields)
        type: bool  default: true
  --track-field-types (track field types)
        type: bool  default: true
  --trace-block-coverage (trace collected block coverage information)
        type: bool  default: false
  --trace-protector-invalidation (trace protector cell invalidations)
        type: bool  default: false
  --feedback-normalization (feed back normalization to constructors)
        type: bool  default: false
  --enable-one-shot-optimization (Enable size optimizations for the code that will only be executed once)
        type: bool  default: false
  --unbox-double-arrays (automatically unbox arrays of doubles)
        type: bool  default: true
  --interrupt-budget (interrupt budget which should be used for the profiler counter)
        type: int  default: 147456
  --jitless (Disable runtime allocation of executable memory.)
        type: bool  default: false
  --use-ic (use inline caching)
        type: bool  default: true
  --budget-for-feedback-vector-allocation (The budget in amount of bytecode executed by a function before we decide to allocate feedback vectors)
        type: int  default: 1024
  --lazy-feedback-allocation (Allocate feedback vectors lazily)
        type: bool  default: true
  --ignition-elide-noneffectful-bytecodes (elide bytecodes which won't have any external effect)
        type: bool  default: true
  --ignition-reo (use ignition register equivalence optimizer)
        type: bool  default: true
  --ignition-filter-expression-positions (filter expression positions before the bytecode pipeline)
        type: bool  default: true
  --ignition-share-named-property-feedback (share feedback slots when loading the same named property from the same object)
        type: bool  default: true
  --print-bytecode (print bytecode generated by ignition interpreter)
        type: bool  default: false
  --enable-lazy-source-positions (skip generating source positions during initial compile but regenerate when actually required)
        type: bool  default: true
  --stress-lazy-source-positions (collect lazy source positions immediately after lazy compile)
        type: bool  default: false
  --print-bytecode-filter (filter for selecting which functions to print bytecode)
        type: string  default: *
  --trace-ignition-codegen (trace the codegen of ignition interpreter bytecode handlers)
        type: bool  default: false
  --trace-ignition-dispatches (traces the dispatches to bytecode handlers by the ignition interpreter)
        type: bool  default: false
  --trace-ignition-dispatches-output-file (the file to which the bytecode handler dispatch table is written (by default, the table is not written to a file))
        type: string  default: nullptr
  --fast-math (faster (but maybe less accurate) math functions)
        type: bool  default: true
  --trace-track-allocation-sites (trace the tracking of allocation sites)
        type: bool  default: false
  --trace-migration (trace object migration)
        type: bool  default: false
  --trace-generalization (trace map generalization)
        type: bool  default: false
  --turboprop (enable experimental turboprop mid-tier compiler.)
        type: bool  default: false
  --concurrent-recompilation (optimizing hot functions asynchronously on a separate thread)
        type: bool  default: true
  --trace-concurrent-recompilation (track concurrent recompilation)
        type: bool  default: false
  --concurrent-recompilation-queue-length (the length of the concurrent compilation queue)
        type: int  default: 8
  --concurrent-recompilation-delay (artificial compilation delay in ms)
        type: int  default: 0
  --block-concurrent-recompilation (block queued jobs until released)
        type: bool  default: false
  --concurrent-inlining (run optimizing compiler's inlining phase on a separate thread)
        type: bool  default: false
  --max-serializer-nesting (maximum levels for nesting child serializers)
        type: int  default: 25
  --trace-heap-broker-verbose (trace the heap broker verbosely (all reports))
        type: bool  default: false
  --trace-heap-broker-memory (trace the heap broker memory (refs analysis and zone numbers))
        type: bool  default: false
  --trace-heap-broker (trace the heap broker (reports on missing data only))
        type: bool  default: false
  --stress-runs (number of stress runs)
        type: int  default: 0
  --deopt-every-n-times (deoptimize every n times a deopt point is passed)
        type: int  default: 0
  --print-deopt-stress (print number of possible deopt points)
        type: bool  default: false
  --opt (use adaptive optimizations)
        type: bool  default: true
  --turbo-sp-frame-access (use stack pointer-relative access to frame wherever possible)
        type: bool  default: false
  --turbo-control-flow-aware-allocation (consider control flow while allocating registers)
        type: bool  default: true
  --turbo-filter (optimization filter for TurboFan compiler)
        type: string  default: *
  --trace-turbo (trace generated TurboFan IR)
        type: bool  default: false
  --trace-turbo-path (directory to dump generated TurboFan IR to)
        type: string  default: nullptr
  --trace-turbo-filter (filter for tracing turbofan compilation)
        type: string  default: *
  --trace-turbo-graph (trace generated TurboFan graphs)
        type: bool  default: false
  --trace-turbo-scheduled (trace TurboFan IR with schedule)
        type: bool  default: false
  --trace-turbo-cfg-file (trace turbo cfg graph (for C1 visualizer) to a given file name)
        type: string  default: nullptr
  --trace-turbo-types (trace TurboFan's types)
        type: bool  default: true
  --trace-turbo-scheduler (trace TurboFan's scheduler)
        type: bool  default: false
  --trace-turbo-reduction (trace TurboFan's various reducers)
        type: bool  default: false
  --trace-turbo-trimming (trace TurboFan's graph trimmer)
        type: bool  default: false
  --trace-turbo-jt (trace TurboFan's jump threading)
        type: bool  default: false
  --trace-turbo-ceq (trace TurboFan's control equivalence)
        type: bool  default: false
  --trace-turbo-loop (trace TurboFan's loop optimizations)
        type: bool  default: false
  --trace-turbo-alloc (trace TurboFan's register allocator)
        type: bool  default: false
  --trace-all-uses (trace all use positions)
        type: bool  default: false
  --trace-representation (trace representation types)
        type: bool  default: false
  --turbo-verify (verify TurboFan graphs at each phase)
        type: bool  default: false
  --turbo-verify-machine-graph (verify TurboFan machine graph before instruction selection)
        type: string  default: nullptr
  --trace-verify-csa (trace code stubs verification)
        type: bool  default: false
  --csa-trap-on-node (trigger break point when a node with given id is created in given stub. The format is: StubName,NodeId)
        type: string  default: nullptr
  --turbo-stats (print TurboFan statistics)
        type: bool  default: false
  --turbo-stats-nvp (print TurboFan statistics in machine-readable format)
        type: bool  default: false
  --turbo-stats-wasm (print TurboFan statistics of wasm compilations)
        type: bool  default: false
  --turbo-splitting (split nodes during scheduling in TurboFan)
        type: bool  default: true
  --function-context-specialization (enable function context specialization in TurboFan)
        type: bool  default: false
  --turbo-inlining (enable inlining in TurboFan)
        type: bool  default: true
  --max-inlined-bytecode-size (maximum size of bytecode for a single inlining)
        type: int  default: 500
  --max-inlined-bytecode-size-cumulative (maximum cumulative size of bytecode considered for inlining)
        type: int  default: 1000
  --max-inlined-bytecode-size-absolute (maximum cumulative size of bytecode considered for inlining)
        type: int  default: 5000
  --reserve-inline-budget-scale-factor (maximum cumulative size of bytecode considered for inlining)
        type: float  default: 1.2
  --max-inlined-bytecode-size-small (maximum size of bytecode considered for small function inlining)
        type: int  default: 30
  --max-optimized-bytecode-size (maximum bytecode size to be considered for optimization; too high values may cause the compiler to hit (release) assertions)
        type: int  default: 61440
  --min-inlining-frequency (minimum frequency for inlining)
        type: float  default: 0.15
  --polymorphic-inlining (polymorphic inlining)
        type: bool  default: true
  --stress-inline (set high thresholds for inlining to inline as much as possible)
        type: bool  default: false
  --trace-turbo-inlining (trace TurboFan inlining)
        type: bool  default: false
  --turbo-inline-array-builtins (inline array builtins in TurboFan code)
        type: bool  default: true
  --use-osr (use on-stack replacement)
        type: bool  default: true
  --trace-osr (trace on-stack replacement)
        type: bool  default: false
  --analyze-environment-liveness (analyze liveness of environment slots and zap dead values)
        type: bool  default: true
  --trace-environment-liveness (trace liveness of local variable slots)
        type: bool  default: false
  --turbo-load-elimination (enable load elimination in TurboFan)
        type: bool  default: true
  --trace-turbo-load-elimination (trace TurboFan load elimination)
        type: bool  default: false
  --turbo-profiling (enable basic block profiling in TurboFan)
        type: bool  default: false
  --turbo-profiling-verbose (enable basic block profiling in TurboFan, and include each function's schedule and disassembly in the output)
        type: bool  default: false
  --turbo-verify-allocation (verify register allocation in TurboFan)
        type: bool  default: false
  --turbo-move-optimization (optimize gap moves in TurboFan)
        type: bool  default: true
  --turbo-jt (enable jump threading in TurboFan)
        type: bool  default: true
  --turbo-loop-peeling (Turbofan loop peeling)
        type: bool  default: true
  --turbo-loop-variable (Turbofan loop variable optimization)
        type: bool  default: true
  --turbo-loop-rotation (Turbofan loop rotation)
        type: bool  default: true
  --turbo-cf-optimization (optimize control flow in TurboFan)
        type: bool  default: true
  --turbo-escape (enable escape analysis)
        type: bool  default: true
  --turbo-allocation-folding (Turbofan allocation folding)
        type: bool  default: true
  --turbo-instruction-scheduling (enable instruction scheduling in TurboFan)
        type: bool  default: false
  --turbo-stress-instruction-scheduling (randomly schedule instructions to stress dependency tracking)
        type: bool  default: false
  --turbo-store-elimination (enable store-store elimination in TurboFan)
        type: bool  default: true
  --trace-store-elimination (trace store elimination)
        type: bool  default: false
  --turbo-rewrite-far-jumps (rewrite far to near jumps (ia32,x64))
        type: bool  default: true
  --stress-gc-during-compilation (simulate GC/compiler thread race related to https://crbug.com/v8/8520)
        type: bool  default: false
  --turbo-fast-api-calls (enable fast API calls from TurboFan)
        type: bool  default: false
  --reuse-opt-code-count (don't discard optimized code for the specified number of deopts.)
        type: int  default: 0
  --turbo-nci (enable experimental native context independent code.)
        type: bool  default: false
  --turbo-nci-as-highest-tier (replace default TF with NCI code as the highest tier for testing purposes.)
        type: bool  default: false
  --print-nci-code (print native context independent code.)
        type: bool  default: false
  --trace-turbo-nci (trace native context independent code.)
        type: bool  default: false
  --turbo-collect-feedback-in-generic-lowering (enable experimental feedback collection in generic lowering.)
        type: bool  default: false
  --optimize-for-size (Enables optimizations which favor memory size over execution speed)
        type: bool  default: false
  --untrusted-code-mitigations (Enable mitigations for executing untrusted code)
        type: bool  default: false
  --expose-wasm (expose wasm interface to JavaScript)
        type: bool  default: true
  --assume-asmjs-origin (force wasm decoder to assume input is internal asm-wasm format)
        type: bool  default: false
  --wasm-num-compilation-tasks (maximum number of parallel compilation tasks for wasm)
        type: int  default: 128
  --wasm-write-protect-code-memory (write protect code memory on the wasm native heap)
        type: bool  default: false
  --wasm-async-compilation (enable actual asynchronous compilation for WebAssembly.compile)
        type: bool  default: true
  --wasm-test-streaming (use streaming compilation instead of async compilation for tests)
        type: bool  default: false
  --wasm-max-mem-pages (maximum initial number of 64KiB memory pages of a wasm instance)
        type: uint  default: 32767
  --wasm-max-mem-pages-growth (maximum number of 64KiB pages a Wasm memory can grow to)
        type: uint  default: 65536
  --wasm-max-table-size (maximum table size of a wasm instance)
        type: uint  default: 10000000
  --wasm-max-code-space (maximum committed code space for wasm (in MB))
        type: uint  default: 1024
  --wasm-tier-up (enable tier up to the optimizing compiler (requires --liftoff to have an effect))
        type: bool  default: true
  --trace-wasm-ast-start (start function for wasm AST trace (inclusive))
        type: int  default: 0
  --trace-wasm-ast-end (end function for wasm AST trace (exclusive))
        type: int  default: 0
  --liftoff (enable Liftoff, the baseline compiler for WebAssembly)
        type: bool  default: true
  --trace-wasm-memory (print all memory updates performed in wasm code)
        type: bool  default: false
  --wasm-tier-mask-for-testing (bitmask of functions to compile with TurboFan instead of Liftoff)
        type: int  default: 0
  --wasm-expose-debug-eval (Expose wasm evaluator support on the CDP)
        type: bool  default: false
  --validate-asm (validate asm.js modules before compiling)
        type: bool  default: true
  --suppress-asm-messages (don't emit asm.js related messages (for golden file testing))
        type: bool  default: false
  --trace-asm-time (log asm.js timing info to the console)
        type: bool  default: false
  --trace-asm-scanner (log tokens encountered by asm.js scanner)
        type: bool  default: false
  --trace-asm-parser (verbose logging of asm.js parse failures)
        type: bool  default: false
  --stress-validate-asm (try to validate everything as asm.js)
        type: bool  default: false
  --dump-wasm-module-path (directory to dump wasm modules to)
        type: string  default: nullptr
  --experimental-wasm-eh (enable prototype exception handling opcodes for wasm)
        type: bool  default: false
  --experimental-wasm-simd (enable prototype SIMD opcodes for wasm)
        type: bool  default: false
  --experimental-wasm-return-call (enable prototype return call opcodes for wasm)
        type: bool  default: false
  --experimental-wasm-compilation-hints (enable prototype compilation hints section for wasm)
        type: bool  default: false
  --experimental-wasm-gc (enable prototype garbage collection for wasm)
        type: bool  default: false
  --experimental-wasm-typed-funcref (enable prototype typed function references for wasm)
        type: bool  default: false
  --experimental-wasm-reftypes (enable prototype reference type opcodes for wasm)
        type: bool  default: false
  --experimental-wasm-threads (enable prototype thread opcodes for wasm)
        type: bool  default: false
  --experimental-wasm-type-reflection (enable prototype wasm type reflection in JS for wasm)
        type: bool  default: false
  --experimental-wasm-bigint (enable prototype JS BigInt support for wasm)
        type: bool  default: true
  --experimental-wasm-bulk-memory (enable prototype bulk memory opcodes for wasm)
        type: bool  default: true
  --experimental-wasm-mv (enable prototype multi-value support for wasm)
        type: bool  default: true
  --wasm-staging (enable staged wasm features)
        type: bool  default: false
  --wasm-opt (enable wasm optimization)
        type: bool  default: false
  --wasm-bounds-checks (enable bounds checks (disable for performance testing only))
        type: bool  default: true
  --wasm-stack-checks (enable stack checks (disable for performance testing only))
        type: bool  default: true
  --wasm-math-intrinsics (intrinsify some Math imports into wasm)
        type: bool  default: true
  --wasm-trap-handler (use signal handlers to catch out of bounds memory access in wasm (currently Linux x86_64 only))
        type: bool  default: true
  --wasm-fuzzer-gen-test (generate a test case when running a wasm fuzzer)
        type: bool  default: false
  --print-wasm-code (Print WebAssembly code)
        type: bool  default: false
  --print-wasm-stub-code (Print WebAssembly stub code)
        type: bool  default: false
  --asm-wasm-lazy-compilation (enable lazy compilation for asm-wasm modules)
        type: bool  default: false
  --wasm-lazy-compilation (enable lazy compilation for all wasm modules)
        type: bool  default: false
  --wasm-lazy-validation (enable lazy validation for lazily compiled wasm functions)
        type: bool  default: false
  --wasm-atomics-on-non-shared-memory (allow atomic operations on non-shared WebAssembly memory)
        type: bool  default: true
  --wasm-grow-shared-memory (allow growing shared WebAssembly memory objects)
        type: bool  default: true
  --wasm-simd-post-mvp (allow experimental SIMD operations for prototyping that are not included in the current proposal)
        type: bool  default: false
  --wasm-code-gc (enable garbage collection of wasm code)
        type: bool  default: true
  --trace-wasm-code-gc (trace garbage collection of wasm code)
        type: bool  default: false
  --stress-wasm-code-gc (stress test garbage collection of wasm code)
        type: bool  default: false
  --wasm-max-initial-code-space-reservation (maximum size of the initial wasm code space reservation (in MB))
        type: int  default: 0
  --frame-count (number of stack frames inspected by the profiler)
        type: int  default: 1
  --stress-sampling-allocation-profiler (Enables sampling allocation profiler with X as a sample interval)
        type: int  default: 0
  --lazy-new-space-shrinking (Enables the lazy new space shrinking strategy)
        type: bool  default: false
  --min-semi-space-size (min size of a semi-space (in MBytes), the new space consists of two semi-spaces)
        type: size_t  default: 0
  --max-semi-space-size (max size of a semi-space (in MBytes), the new space consists of two semi-spaces)
        type: size_t  default: 0
  --semi-space-growth-factor (factor by which to grow the new space)
        type: int  default: 2
  --max-old-space-size (max size of the old space (in Mbytes))
        type: size_t  default: 0
  --max-heap-size (max size of the heap (in Mbytes) both max_semi_space_size and max_old_space_size take precedence. All three flags cannot be specified at the same time.)
        type: size_t  default: 0
  --initial-heap-size (initial size of the heap (in Mbytes))
        type: size_t  default: 0
  --huge-max-old-generation-size (Increase max size of the old space to 4 GB for x64 systems withthe physical memory bigger than 16 GB)
        type: bool  default: true
  --initial-old-space-size (initial old space size (in Mbytes))
        type: size_t  default: 0
  --global-gc-scheduling (enable GC scheduling based on global memory)
        type: bool  default: true
  --gc-global (always perform global GCs)
        type: bool  default: false
  --random-gc-interval (Collect garbage after random(0, X) allocations. It overrides gc_interval.)
        type: int  default: 0
  --gc-interval (garbage collect after &lt;n&gt; allocations)
        type: int  default: -1
  --retain-maps-for-n-gc (keeps maps alive for &lt;n&gt; old space garbage collections)
        type: int  default: 2
  --trace-gc (print one trace line following each garbage collection)
        type: bool  default: false
  --trace-gc-nvp (print one detailed trace line in name=value format after each garbage collection)
        type: bool  default: false
  --trace-gc-ignore-scavenger (do not print trace line after scavenger collection)
        type: bool  default: false
  --trace-idle-notification (print one trace line following each idle notification)
        type: bool  default: false
  --trace-idle-notification-verbose (prints the heap state used by the idle notification)
        type: bool  default: false
  --trace-gc-verbose (print more details following each garbage collection)
        type: bool  default: false
  --trace-gc-freelists (prints details of each freelist before and after each major garbage collection)
        type: bool  default: false
  --trace-gc-freelists-verbose (prints details of freelists of each page before and after each major garbage collection)
        type: bool  default: false
  --trace-evacuation-candidates (Show statistics about the pages evacuation by the compaction)
        type: bool  default: false
  --trace-allocations-origins (Show statistics about the origins of allocations. Combine with --no-inline-new to track allocations from generated code)
        type: bool  default: false
  --trace-allocation-stack-interval (print stack trace after &lt;n&gt; free-list allocations)
        type: int  default: -1
  --trace-duplicate-threshold-kb (print duplicate objects in the heap if their size is more than given threshold)
        type: int  default: 0
  --trace-fragmentation (report fragmentation for old space)
        type: bool  default: false
  --trace-fragmentation-verbose (report fragmentation for old space (detailed))
        type: bool  default: false
  --minor-mc-trace-fragmentation (trace fragmentation after marking)
        type: bool  default: false
  --trace-evacuation (report evacuation statistics)
        type: bool  default: false
  --trace-mutator-utilization (print mutator utilization, allocation speed, gc speed)
        type: bool  default: false
  --incremental-marking (use incremental marking)
        type: bool  default: true
  --incremental-marking-wrappers (use incremental marking for marking wrappers)
        type: bool  default: true
  --incremental-marking-task (use tasks for incremental marking)
        type: bool  default: true
  --incremental-marking-soft-trigger (threshold for starting incremental marking via a task in percent of available space: limit - size)
        type: int  default: 0
  --incremental-marking-hard-trigger (threshold for starting incremental marking immediately in percent of available space: limit - size)
        type: int  default: 0
  --trace-unmapper (Trace the unmapping)
        type: bool  default: false
  --parallel-scavenge (parallel scavenge)
        type: bool  default: true
  --scavenge-task (schedule scavenge tasks)
        type: bool  default: true
  --scavenge-task-trigger (scavenge task trigger in percent of the current heap limit)
        type: int  default: 80
  --scavenge-separate-stack-scanning (use a separate phase for stack scanning in scavenge)
        type: bool  default: false
  --trace-parallel-scavenge (trace parallel scavenge)
        type: bool  default: false
  --write-protect-code-memory (write protect code memory)
        type: bool  default: true
  --concurrent-marking (use concurrent marking)
        type: bool  default: true
  --concurrent-array-buffer-sweeping (concurrently sweep array buffers)
        type: bool  default: true
  --concurrent-allocation (concurrently allocate in old space)
        type: bool  default: false
  --local-heaps (allow heap access from background tasks)
        type: bool  default: false
  --stress-concurrent-allocation (start background threads that allocate memory)
        type: bool  default: false
  --parallel-marking (use parallel marking in atomic pause)
        type: bool  default: true
  --ephemeron-fixpoint-iterations (number of fixpoint iterations it takes to switch to linear ephemeron algorithm)
        type: int  default: 10
  --trace-concurrent-marking (trace concurrent marking)
        type: bool  default: false
  --concurrent-store-buffer (use concurrent store buffer processing)
        type: bool  default: true
  --concurrent-sweeping (use concurrent sweeping)
        type: bool  default: true
  --parallel-compaction (use parallel compaction)
        type: bool  default: true
  --parallel-pointer-update (use parallel pointer update during compaction)
        type: bool  default: true
  --detect-ineffective-gcs-near-heap-limit (trigger out-of-memory failure to avoid GC storm near heap limit)
        type: bool  default: true
  --trace-incremental-marking (trace progress of the incremental marking)
        type: bool  default: false
  --trace-stress-marking (trace stress marking progress)
        type: bool  default: false
  --trace-stress-scavenge (trace stress scavenge progress)
        type: bool  default: false
  --track-gc-object-stats (track object counts and memory usage)
        type: bool  default: false
  --trace-gc-object-stats (trace object counts and memory usage)
        type: bool  default: false
  --trace-zone-stats (trace zone memory usage)
        type: bool  default: false
  --zone-stats-tolerance (report a tick only when allocated zone memory changes by this amount)
        type: size_t  default: 1048576
  --track-retaining-path (enable support for tracking retaining path)
        type: bool  default: false
  --concurrent-array-buffer-freeing (free array buffer allocations on a background thread)
        type: bool  default: true
  --gc-stats (Used by tracing internally to enable gc statistics)
        type: int  default: 0
  --track-detached-contexts (track native contexts that are expected to be garbage collected)
        type: bool  default: true
  --trace-detached-contexts (trace native contexts that are expected to be garbage collected)
        type: bool  default: false
  --move-object-start (enable moving of object starts)
        type: bool  default: true
  --memory-reducer (use memory reducer)
        type: bool  default: true
  --memory-reducer-for-small-heaps (use memory reducer for small heaps)
        type: bool  default: true
  --heap-growing-percent (specifies heap growing factor as (1 + heap_growing_percent/100))
        type: int  default: 0
  --v8-os-page-size (override OS page size (in KBytes))
        type: int  default: 0
  --always-compact (Perform compaction on every full GC)
        type: bool  default: false
  --never-compact (Never perform compaction on full GC - testing only)
        type: bool  default: false
  --compact-code-space (Compact code space on full collections)
        type: bool  default: true
  --flush-bytecode (flush of bytecode when it has not been executed recently)
        type: bool  default: true
  --stress-flush-bytecode (stress bytecode flushing)
        type: bool  default: false
  --use-marking-progress-bar (Use a progress bar to scan large objects in increments when incremental marking is active.)
        type: bool  default: true
  --stress-per-context-marking-worklist (Use per-context worklist for marking)
        type: bool  default: false
  --force-marking-deque-overflows (force overflows of marking deque by reducing it's size to 64 words)
        type: bool  default: false
  --stress-compaction (stress the GC compactor to flush out bugs (implies --force_marking_deque_overflows))
        type: bool  default: false
  --stress-compaction-random (Stress GC compaction by selecting random percent of pages as evacuation candidates. It overrides stress_compaction.)
        type: bool  default: false
  --stress-incremental-marking (force incremental marking for small heaps and run it more often)
        type: bool  default: false
  --fuzzer-gc-analysis (prints number of allocations and enables analysis mode for gc fuzz testing, e.g. --stress-marking, --stress-scavenge)
        type: bool  default: false
  --stress-marking (force marking at random points between 0 and X (inclusive) percent of the regular marking start limit)
        type: int  default: 0
  --stress-scavenge (force scavenge at random points between 0 and X (inclusive) percent of the new space capacity)
        type: int  default: 0
  --gc-experiment-background-schedule (new background GC schedule heuristics)
        type: bool  default: false
  --gc-experiment-less-compaction (less compaction in non-memory reducing mode)
        type: bool  default: false
  --disable-abortjs (disables AbortJS runtime function)
        type: bool  default: false
  --randomize-all-allocations (randomize virtual memory reservations by ignoring any hints passed when allocating pages)
        type: bool  default: false
  --manual-evacuation-candidates-selection (Test mode only flag. It allows an unit test to select evacuation candidates pages (requires --stress_compaction).)
        type: bool  default: false
  --fast-promotion-new-space (fast promote new space on high survival rates)
        type: bool  default: false
  --clear-free-memory (initialize free memory with 0)
        type: bool  default: false
  --young-generation-large-objects (allocates large objects by default in the young generation large object space)
        type: bool  default: true
  --debug-code (generate extra code (assertions) for debugging)
        type: bool  default: false
  --code-comments (emit comments in code disassembly; for more readable source positions you should add --no-concurrent_recompilation)
        type: bool  default: false
  --enable-sse3 (enable use of SSE3 instructions if available)
        type: bool  default: true
  --enable-ssse3 (enable use of SSSE3 instructions if available)
        type: bool  default: true
  --enable-sse4-1 (enable use of SSE4.1 instructions if available)
        type: bool  default: true
  --enable-sse4-2 (enable use of SSE4.2 instructions if available)
        type: bool  default: true
  --enable-sahf (enable use of SAHF instruction if available (X64 only))
        type: bool  default: true
  --enable-avx (enable use of AVX instructions if available)
        type: bool  default: true
  --enable-fma3 (enable use of FMA3 instructions if available)
        type: bool  default: true
  --enable-bmi1 (enable use of BMI1 instructions if available)
        type: bool  default: true
  --enable-bmi2 (enable use of BMI2 instructions if available)
        type: bool  default: true
  --enable-lzcnt (enable use of LZCNT instruction if available)
        type: bool  default: true
  --enable-popcnt (enable use of POPCNT instruction if available)
        type: bool  default: true
  --arm-arch (generate instructions for the selected ARM architecture if available: armv6, armv7, armv7+sudiv or armv8)
        type: string  default: armv8
  --force-long-branches (force all emitted branches to be in long mode (MIPS/PPC only))
        type: bool  default: false
  --mcpu (enable optimization for specific cpu)
        type: string  default: auto
  --partial-constant-pool (enable use of partial constant pools (X64 only))
        type: bool  default: true
  --sim-arm64-optional-features (enable optional features on the simulator for testing: none or all)
        type: string  default: none
  --enable-source-at-csa-bind (Include source information in the binary at CSA bind locations.)
        type: bool  default: false
  --enable-armv7 (deprecated (use --arm_arch instead))
        type: maybe_bool  default: unset
  --enable-vfp3 (deprecated (use --arm_arch instead))
        type: maybe_bool  default: unset
  --enable-32dregs (deprecated (use --arm_arch instead))
        type: maybe_bool  default: unset
  --enable-neon (deprecated (use --arm_arch instead))
        type: maybe_bool  default: unset
  --enable-sudiv (deprecated (use --arm_arch instead))
        type: maybe_bool  default: unset
  --enable-armv8 (deprecated (use --arm_arch instead))
        type: maybe_bool  default: unset
  --enable-regexp-unaligned-accesses (enable unaligned accesses for the regexp engine)
        type: bool  default: true
  --script-streaming (enable parsing on background)
        type: bool  default: true
  --stress-background-compile (stress test parsing on background)
        type: bool  default: false
  --finalize-streaming-on-background (perform the script streaming finalization on the background thread)
        type: bool  default: false
  --disable-old-api-accessors (Disable old-style API accessors whose setters trigger through the prototype chain)
        type: bool  default: false
  --expose-gc (expose gc extension)
        type: bool  default: false
  --expose-gc-as (expose gc extension under the specified name)
        type: string  default: nullptr
  --expose-externalize-string (expose externalize string extension)
        type: bool  default: false
  --expose-trigger-failure (expose trigger-failure extension)
        type: bool  default: false
  --stack-trace-limit (number of stack frames to capture)
        type: int  default: 10
  --builtins-in-stack-traces (show built-in functions in stack traces)
        type: bool  default: false
  --experimental-stack-trace-frames (enable experimental frames (API/Builtins) and stack trace layout)
        type: bool  default: false
  --disallow-code-generation-from-strings (disallow eval and friends)
        type: bool  default: false
  --expose-async-hooks (expose async_hooks object)
        type: bool  default: false
  --expose-cputracemark-as (expose cputracemark extension under the specified name)
        type: string  default: nullptr
  --allow-unsafe-function-constructor (allow invoking the function constructor without security checks)
        type: bool  default: false
  --force-slow-path (always take the slow path for builtins)
        type: bool  default: false
  --test-small-max-function-context-stub-size (enable testing the function context size overflow path by making the maximum size smaller)
        type: bool  default: false
  --inline-new (use fast inline allocation)
        type: bool  default: true
  --trace (trace javascript function calls)
        type: bool  default: false
  --trace-wasm (trace wasm function calls)
        type: bool  default: false
  --lazy (use lazy compilation)
        type: bool  default: true
  --max-lazy (ignore eager compilation hints)
        type: bool  default: false
  --trace-opt (trace lazy optimization)
        type: bool  default: false
  --trace-opt-verbose (extra verbose compilation tracing)
        type: bool  default: false
  --trace-opt-stats (trace lazy optimization statistics)
        type: bool  default: false
  --trace-deopt (trace optimize function deoptimization)
        type: bool  default: false
  --trace-file-names (include file names in trace-opt/trace-deopt output)
        type: bool  default: false
  --always-opt (always try to optimize functions)
        type: bool  default: false
  --always-osr (always try to OSR functions)
        type: bool  default: false
  --prepare-always-opt (prepare for turning on always opt)
        type: bool  default: false
  --trace-serializer (print code serializer trace)
        type: bool  default: false
  --compilation-cache (enable compilation cache)
        type: bool  default: true
  --cache-prototype-transitions (cache prototype transitions)
        type: bool  default: true
  --parallel-compile-tasks (enable parallel compile tasks)
        type: bool  default: false
  --compiler-dispatcher (enable compiler dispatcher)
        type: bool  default: false
  --trace-compiler-dispatcher (trace compiler dispatcher activity)
        type: bool  default: false
  --cpu-profiler-sampling-interval (CPU profiler sampling interval in microseconds)
        type: int  default: 1000
  --trace-side-effect-free-debug-evaluate (print debug messages for side-effect-free debug-evaluate for testing)
        type: bool  default: false
  --hard-abort (abort by crashing)
        type: bool  default: true
  --expose-inspector-scripts (expose injected-script-source.js for debugging)
        type: bool  default: false
  --stack-size (default size of stack region v8 is allowed to use (in kBytes))
        type: int  default: 984
  --max-stack-trace-source-length (maximum length of function source code printed in a stack trace.)
        type: int  default: 300
  --clear-exceptions-on-js-entry (clear pending exceptions when entering JavaScript)
        type: bool  default: false
  --histogram-interval (time interval in ms for aggregating memory histograms)
        type: int  default: 600000
  --heap-profiler-trace-objects (Dump heap object allocations/movements/size_updates)
        type: bool  default: false
  --heap-profiler-use-embedder-graph (Use the new EmbedderGraph API to get embedder nodes)
        type: bool  default: true
  --heap-snapshot-string-limit (truncate strings to this length in the heap snapshot)
        type: int  default: 1024
  --sampling-heap-profiler-suppress-randomness (Use constant sample intervals to eliminate test flakiness)
        type: bool  default: false
  --use-idle-notification (Use idle notification to reduce memory footprint.)
        type: bool  default: true
  --trace-ic (trace inline cache state transitions for tools/ic-processor)
        type: bool  default: false
  --modify-field-representation-inplace (enable in-place field representation updates)
        type: bool  default: true
  --max-polymorphic-map-count (maximum number of maps to track in POLYMORPHIC state)
        type: int  default: 4
  --native-code-counters (generate extra code for manipulating stats counters)
        type: bool  default: false
  --thin-strings (Enable ThinString support)
        type: bool  default: true
  --trace-prototype-users (Trace updates to prototype user tracking)
        type: bool  default: false
  --trace-for-in-enumerate (Trace for-in enumerate slow-paths)
        type: bool  default: false
  --trace-maps (trace map creation)
        type: bool  default: false
  --trace-maps-details (also log map details)
        type: bool  default: true
  --allow-natives-syntax (allow natives syntax)
        type: bool  default: false
  --allow-natives-for-differential-fuzzing (allow only natives explicitly allowlisted for differential fuzzers)
        type: bool  default: false
  --parse-only (only parse the sources)
        type: bool  default: false
  --trace-sim (Trace simulator execution)
        type: bool  default: false
  --debug-sim (Enable debugging the simulator)
        type: bool  default: false
  --check-icache (Check icache flushes in ARM and MIPS simulator)
        type: bool  default: false
  --stop-sim-at (Simulator stop after x number of instructions)
        type: int  default: 0
  --sim-stack-alignment (Stack alingment in bytes in simulator (4 or 8, 8 is default))
        type: int  default: 8
  --sim-stack-size (Stack size of the ARM64, MIPS64 and PPC64 simulator in kBytes (default is 2 MB))
        type: int  default: 2048
  --log-colour (When logging, try to use coloured output.)
        type: bool  default: true
  --trace-sim-messages (Trace simulator debug messages. Implied by --trace-sim.)
        type: bool  default: false
  --async-stack-traces (include async stack traces in Error.stack)
        type: bool  default: true
  --stack-trace-on-illegal (print stack trace when an illegal exception is thrown)
        type: bool  default: false
  --abort-on-uncaught-exception (abort program (dump core) when an uncaught exception is thrown)
        type: bool  default: false
  --correctness-fuzzer-suppressions (Suppress certain unspecified behaviors to ease correctness fuzzing: Abort program when the stack overflows or a string exceeds maximum length (as opposed to throwing RangeError). Use a fixed suppression string for error messages.)
        type: bool  default: false
  --randomize-hashes (randomize hashes to avoid predictable hash collisions (with snapshots this option cannot override the baked-in seed))
        type: bool  default: true
  --rehash-snapshot (rehash strings from the snapshot to override the baked-in seed)
        type: bool  default: true
  --hash-seed (Fixed seed to use to hash property keys (0 means random)(with snapshots this option cannot override the baked-in seed))
        type: uint64  default: 0
  --random-seed (Default seed for initializing random generator (0, the default, means to use system random).)
        type: int  default: 0
  --fuzzer-random-seed (Default seed for initializing fuzzer random generator (0, the default, means to use v8's random number generator seed).)
        type: int  default: 0
  --trace-rail (trace RAIL mode)
        type: bool  default: false
  --print-all-exceptions (print exception object and stack trace on each thrown exception)
        type: bool  default: false
  --detailed-error-stack-trace (includes arguments for each function call in the error stack frames array)
        type: bool  default: false
  --adjust-os-scheduling-parameters (adjust OS specific scheduling params for the isolate)
        type: bool  default: true
  --runtime-call-stats (report runtime call counts and times)
        type: bool  default: false
  --rcs (report runtime call counts and times)
        type: bool  default: false
  --rcs-cpu-time (report runtime times in cpu time (the default is wall time))
        type: bool  default: false
  --profile-deserialization (Print the time it takes to deserialize the snapshot.)
        type: bool  default: false
  --serialization-statistics (Collect statistics on serialized objects.)
        type: bool  default: false
  --serialization-chunk-size (Custom size for serialization chunks)
        type: uint  default: 4096
  --regexp-optimization (generate optimized regexp code)
        type: bool  default: true
  --regexp-mode-modifiers (enable inline flags in regexp.)
        type: bool  default: false
  --regexp-interpret-all (interpret all regexp code)
        type: bool  default: false
  --regexp-tier-up (enable regexp interpreter and tier up to the compiler after the number of executions set by the tier up ticks flag)
        type: bool  default: true
  --regexp-tier-up-ticks (set the number of executions for the regexp interpreter before tiering-up to the compiler)
        type: int  default: 1
  --regexp-peephole-optimization (enable peephole optimization for regexp bytecode)
        type: bool  default: true
  --trace-regexp-peephole-optimization (trace regexp bytecode peephole optimization)
        type: bool  default: false
  --trace-regexp-bytecodes (trace regexp bytecode execution)
        type: bool  default: false
  --trace-regexp-assembler (trace regexp macro assembler calls.)
        type: bool  default: false
  --trace-regexp-parser (trace regexp parsing)
        type: bool  default: false
  --trace-regexp-tier-up (trace regexp tiering up execution)
        type: bool  default: false
  --testing-bool-flag (testing_bool_flag)
        type: bool  default: true
  --testing-maybe-bool-flag (testing_maybe_bool_flag)
        type: maybe_bool  default: unset
  --testing-int-flag (testing_int_flag)
        type: int  default: 13
  --testing-float-flag (float-flag)
        type: float  default: 2.5
  --testing-string-flag (string-flag)
        type: string  default: Hello, world!
  --testing-prng-seed (Seed used for threading test randomness)
        type: int  default: 42
  --testing-d8-test-runner (test runner turns on this flag to enable a check that the function was prepared for optimization before marking it for optimization)
        type: bool  default: false
  --fuzzing (Fuzzers use this flag to signal that they are ... fuzzing. This causes intrinsics to fail silently (e.g. return undefined) on invalid usage.)
        type: bool  default: false
  --embedded-src (Path for the generated embedded data file. (mksnapshot only))
        type: string  default: nullptr
  --embedded-variant (Label to disambiguate symbols in embedded data file. (mksnapshot only))
        type: string  default: nullptr
  --startup-src (Write V8 startup as C++ src. (mksnapshot only))
        type: string  default: nullptr
  --startup-blob (Write V8 startup blob file. (mksnapshot only))
        type: string  default: nullptr
  --target-arch (The mksnapshot target arch. (mksnapshot only))
        type: string  default: nullptr
  --target-os (The mksnapshot target os. (mksnapshot only))
        type: string  default: nullptr
  --target-is-simulator (Instruct mksnapshot that the target is meant to run in the simulator and it can generate simulator-specific instructions. (mksnapshot only))
        type: bool  default: false
  --minor-mc-parallel-marking (use parallel marking for the young generation)
        type: bool  default: true
  --trace-minor-mc-parallel-marking (trace parallel marking for the young generation)
        type: bool  default: false
  --minor-mc (perform young generation mark compact GCs)
        type: bool  default: false
  --help (Print usage message, including flags, on console)
        type: bool  default: true
  --dump-counters (Dump counters on exit)
        type: bool  default: false
  --dump-counters-nvp (Dump counters as name-value pairs on exit)
        type: bool  default: false
  --use-external-strings (Use external strings for source code)
        type: bool  default: false
  --map-counters (Map counters to a file)
        type: string  default:
  --mock-arraybuffer-allocator (Use a mock ArrayBuffer allocator for testing.)
        type: bool  default: false
  --mock-arraybuffer-allocator-limit (Memory limit for mock ArrayBuffer allocator used to simulate OOM for testing.)
        type: size_t  default: 0
  --gdbjit (enable GDBJIT interface)
        type: bool  default: false
  --gdbjit-full (enable GDBJIT interface for all code objects)
        type: bool  default: false
  --gdbjit-dump (dump elf objects with debug info to disk)
        type: bool  default: false
  --gdbjit-dump-filter (dump only objects containing this substring)
        type: string  default:
  --log (Minimal logging (no API, code, GC, suspect, or handles samples).)
        type: bool  default: false
  --log-all (Log all events to the log file.)
        type: bool  default: false
  --log-api (Log API events to the log file.)
        type: bool  default: false
  --log-code (Log code events to the log file without profiling.)
        type: bool  default: false
  --log-handles (Log global handle events.)
        type: bool  default: false
  --log-suspect (Log suspect operations.)
        type: bool  default: false
  --log-source-code (Log source code.)
        type: bool  default: false
  --log-function-events (Log function events (parse, compile, execute) separately.)
        type: bool  default: false
  --prof (Log statistical profiling information (implies --log-code).)
        type: bool  default: false
  --detailed-line-info (Always generate detailed line information for CPU profiling.)
        type: bool  default: false
  --prof-sampling-interval (Interval for --prof samples (in microseconds).)
        type: int  default: 1000
  --prof-cpp (Like --prof, but ignore generated code.)
        type: bool  default: false
  --prof-browser-mode (Used with --prof, turns on browser-compatible mode for profiling.)
        type: bool  default: true
  --logfile (Specify the name of the log file.)
        type: string  default: v8.log
  --logfile-per-isolate (Separate log files for each isolate.)
        type: bool  default: true
  --ll-prof (Enable low-level linux profiler.)
        type: bool  default: false
  --gc-fake-mmap (Specify the name of the file for fake gc mmap used in ll_prof)
        type: string  default: /tmp/__v8_gc__
  --log-internal-timer-events (Time internal events.)
        type: bool  default: false
  --redirect-code-traces (output deopt information and disassembly into file code-&lt;pid&gt;-&lt;isolate id&gt;.asm)
        type: bool  default: false
  --redirect-code-traces-to (output deopt information and disassembly into the given file)
        type: string  default: nullptr
  --print-opt-source (print source code of optimized and inlined functions)
        type: bool  default: false
  --vtune-prof-annotate-wasm (Used when v8_enable_vtunejit is enabled, load wasm source map and provide annotate support (experimental).)
        type: bool  default: false
  --win64-unwinding-info (Enable unwinding info for Windows/x64)
        type: bool  default: true
  --interpreted-frames-native-stack (Show interpreted frames on the native stack (useful for external profilers).)
        type: bool  default: false
  --predictable (enable predictable mode)
        type: bool  default: false
  --predictable-gc-schedule (Predictable garbage collection schedule. Fixes heap growing, idle, and memory reducing behavior.)
        type: bool  default: false
  --single-threaded (disable the use of background tasks)
        type: bool  default: false
  --single-threaded-gc (disable the use of background gc tasks)
        type: bool  default: false
</code></pre>
<p>特别有用的：</p>
<pre><code>--async-stack-trace
</code></pre>
<h3><a class="header" href="#持续的性能测试" id="持续的性能测试">持续的性能测试</a></h3>
<p>参考我们的测试 <a href="https://deno.land/benchmarks">https://deno.land/benchmarks</a></p>
<p>测试图表假设 <a href="https://github.com/denoland/benchmark_data/blob/gh-pages/data.json">https://github.com/denoland/benchmark_data/blob/gh-pages/data.json</a> 有着 <code>BenchmarkData[]</code> 类型。以下是 <code>BenchmarkData</code> 的定义：</p>
<pre><code class="language-ts">interface ExecTimeData {
  mean: number;
  stddev: number;
  user: number;
  system: number;
  min: number;
  max: number;
}

interface BenchmarkData {
  created_at: string;
  sha1: string;
  benchmark: {
    [key: string]: ExecTimeData;
  };
  binarySizeData: {
    [key: string]: number;
  };
  threadCountData: {
    [key: string]: number;
  };
  syscallCountData: {
    [key: string]: number;
  };
}
</code></pre>
<h1><a class="header" href="#deno-风格指南" id="deno-风格指南">Deno 风格指南</a></h1>
<h2><a class="header" href="#目录" id="目录">目录</a></h2>
<h2><a class="header" href="#版权标题" id="版权标题">版权标题</a></h2>
<p>存储库中的大多数模块都应具有以下版权标题:</p>
<pre><code class="language-ts">// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
</code></pre>
<p>如果代码来源于其他地方，请确保文件拥有适当的版权拥有者。 我们只允许 MIT、BSD 和 Apache 许可代码。</p>
<h2><a class="header" href="#在文件名中使用下划线而不是破折号" id="在文件名中使用下划线而不是破折号">在文件名中使用下划线，而不是破折号</a></h2>
<p>例如: 将文件命名为 <code>file_server.ts</code> 而不是 <code>file-server.ts</code>。</p>
<h2><a class="header" href="#为新特性添加测试" id="为新特性添加测试">为新特性添加测试</a></h2>
<p>每个模块都应该包含或伴随着对其公共功能的测试。</p>
<h2><a class="header" href="#todo-注释" id="todo-注释">TODO 注释</a></h2>
<p>TODO 注释通常应该将一个 issue 或者作者的 github 用户名放在括号中。例如:</p>
<pre><code class="language-ts">// TODO(ry): Add tests.
// TODO(#123): Support Windows.
// FIXME(#349): Sometimes panics.
</code></pre>
<h2><a class="header" href="#不建议使用元编程meta-programming包括代理proxy的使用" id="不建议使用元编程meta-programming包括代理proxy的使用">不建议使用元编程（Meta-programming），包括代理（Proxy）的使用</a></h2>
<p>即使要写更多的代码，也要力求明确。</p>
<p>在某些情况下，使用这些技术可能是有意义的，但是在绝大多数情况下，它们是没有意义的。</p>
<h2><a class="header" href="#包含代码inclusive-code" id="包含代码inclusive-code">包含代码（Inclusive code）</a></h2>
<p>请遵循有关包含代码的准则，网址为：</p>
<p><a href="https://chromium.googlesource.com/chromium/src/+/master/styleguide/inclusive_code.md">https://chromium.googlesource.com/chromium/src/+/master/styleguide/inclusive_code.md</a></p>
<h2><a class="header" href="#rust" id="rust">Rust</a></h2>
<p>遵循 Rust 约定，并与现有代码保持一致。</p>
<h2><a class="header" href="#typescript" id="typescript">Typescript</a></h2>
<p>代码库的 TypeScript 部分包括内置的 <code>cli/js</code> 和标准库 <code>std</code>。</p>
<h3><a class="header" href="#使用-typescript-而不是-javascript" id="使用-typescript-而不是-javascript">使用 TypeScript 而不是 JavaScript</a></h3>
<h3><a class="header" href="#使用术语模块module而不是库library或包package" id="使用术语模块module而不是库library或包package">使用术语“模块（module）”，而不是“库（library）”或“包（package）”</a></h3>
<p>为了保证明确性和一致性，避免使用术语 “library” 和 “package” ，而是使用 “module” 来引用一个 JS 或 TS 文件，或者一个 TS/JS 代码目录。</p>
<h3><a class="header" href="#不要使用-indexts-或-indexjs-作为文件名" id="不要使用-indexts-或-indexjs-作为文件名">不要使用 <code>index.ts</code> 或 <code>index.js</code> 作为文件名</a></h3>
<p>Deno 不会以特殊的方式处理 “index.js” 或 “index.ts” 文件。如果使用了这些名称，就意味着当它们需要模块说明符时，可能被排除在外。这会造成误解。</p>
<p>如果一个代码目录需要一个默认的入口点，使用文件名 <code>mod.ts</code>。 文件名 <code>mod.ts</code> 遵循 Rust 的约定，比 <code>index.ts</code> 短，并且没有任何关于它如何工作的先入为主的概念。</p>
<h3><a class="header" href="#导出函数exported-functions-最多-2-个参数其余的放入一个选项对象options-object" id="导出函数exported-functions-最多-2-个参数其余的放入一个选项对象options-object">导出函数（Exported functions）: 最多 2 个参数，其余的放入一个选项对象（options object）</a></h3>
<p>在设计函数接口时，请严格遵循以下规则：</p>
<ol>
<li>
<p>若某函数是公共 API 的一部分，则其可以接受 0~2 个参数，如果必要的话，可以外加一个选项对象，因此最大总数为 3 个。</p>
</li>
<li>
<p>可选参数通常应放到选项对象中。</p>
<p>如果只有一个可选参数，并且将来一般不会添加更多可选参数，那么该可选参数可以不放在选项对象中。</p>
</li>
<li>
<p>选项参数是唯一一个常规对象参数</p>
<p>其他参数可以是对象，但它们在运行时必须能区别于其他一般的对象（&quot;plain&quot; Object）。有以下两种方法进行区别：</p>
<ul>
<li>一个独特的原型（例如：<code>Array</code>，<code>Map</code>，<code>Date</code>，<code>class MyThing</code>）</li>
<li>一个众所周知的符号属性（例如 <code>Symbol.iterator</code>）</li>
</ul>
<p>这允许 API 以向后兼容的方式发展，即使选项对象的位置发生了变化。</p>
</li>
</ol>
<pre><code class="language-ts">// 错误示例：可选参数不是选项对象的一部分 (#2)
export function resolve(
  hostname: string,
  family?: &quot;ipv4&quot; | &quot;ipv6&quot;,
  timeout?: number,
): IPAddress[] {}

// 正确示例：
export interface ResolveOptions {
  family?: &quot;ipv4&quot; | &quot;ipv6&quot;;
  timeout?: number;
}
export function resolve(
  hostname: string,
  options: ResolveOptions = {},
): IPAddress[] {}
</code></pre>
<pre><code class="language-ts">export interface Environment {
  [key: string]: string;
}

// 错误示例：`env`可以是一个常规对象，因此无法与选项对象区分 (#3)
export function runShellWithEnv(cmdline: string, env: Environment): string {}

// 正确示例
export interface RunShellOptions {
  env: Environment;
}
export function runShellWithEnv(
  cmdline: string,
  options: RunShellOptions,
): string {}
</code></pre>
<pre><code class="language-ts">// 错误示例：多于3个参数 (#1)，多个可选参数 (#2)。
export function renameSync(
  oldname: string,
  newname: string,
  replaceExisting?: boolean,
  followLinks?: boolean,
) {}

// 正确示例
interface RenameOptions {
  replaceExisting?: boolean;
  followLinks?: boolean;
}
export function renameSync(
  oldname: string,
  newname: string,
  options: RenameOptions = {},
) {}
</code></pre>
<pre><code class="language-ts">// 错误示例：参数过多 (#1)
export function pwrite(
  fd: number,
  buffer: TypedArray,
  offset: number,
  length: number,
  position: number,
) {}

// 正确示例：
export interface PWrite {
  fd: number;
  buffer: TypedArray;
  offset: number;
  length: number;
  position: number;
}
export function pwrite(options: PWrite) {}
</code></pre>
<h3><a class="header" href="#尽量降低依赖性不要进行循环导入" id="尽量降低依赖性不要进行循环导入">尽量降低依赖性；不要进行循环导入</a></h3>
<p>尽管 <code>cli/js</code> 和 <code>std</code> 没有外部依赖关系，但仍然必须注意保持内部依赖关系的简单性和可管理性。请尤为注意，不要引入循环导入。</p>
<h3><a class="header" href="#不要连接到文件名以下划线开头的文件如_foots" id="不要连接到文件名以下划线开头的文件如_foots">不要连接到文件名以下划线开头的文件，如：<code>_foo.ts</code></a></h3>
<p>有时候可能需要一个内部模块，但是它的 API 并不稳定或者不被连接。这种情况下，在文件名前面加一个下划线。按照惯例，只有它自己目录中的文件才能导入它。</p>
<h3><a class="header" href="#对导出的符号使用-jsdoc" id="对导出的符号使用-jsdoc">对导出的符号使用 JSDoc</a></h3>
<p>我们力求文档的完整性。理想情况下，每个导出的文档符号都应该有一个文档行。</p>
<p>如果可能的话，最好写单行 JSDoc。例如:</p>
<pre><code class="language-ts">/** foo does bar. */
export function foo() {
  // ...
}
</code></pre>
<p>文档易于阅读是很重要的，但是还需要提供额外的样式信息，以确保生成的文档有更丰富的含义。因此，JSDoc 通常应该遵循 markdown 标记来丰富文本。</p>
<p>虽然 markdown 支持 HTML 标记，但是在 JSDoc 块中是禁止的。</p>
<p>代码字符串文字应使用反引号（`）括起来，而不是用引号。例如：</p>
<pre><code class="language-ts">/** Import something from the `deno` module. */
</code></pre>
<p>不要记录函数参数，除非它们的意图不明显（当然，如果它们没有明显的意图，应该重新考虑 API 的设计）。因此，通常不应使用 <code>@param</code>。如果使用了 <code>@param</code>，则不应该包含 <code>type</code> ，因为 TypeScript 已经是强类型化的了。</p>
<pre><code class="language-ts">/**
 * Function with non obvious param.
 * @param foo Description of non obvious parameter.
 */
</code></pre>
<p>应尽可能减小垂直间距。因此单行注释应写为：</p>
<pre><code class="language-ts">/** 这样写单行 JSDoc 注释。 */
</code></pre>
<p>不要写为：</p>
<pre><code class="language-ts">/**
 * 不要这样写单行 JSDoc 注释。
 */
</code></pre>
<p>代码示例不应使用三个反引号（```）标记。它们应该用缩进标记，要求在示例代码块前加入一个空行，并且示例代码的每一行需要有 6 个额外空格。比注释的第一列多 4 个空格。例如：</p>
<pre><code class="language-ts">/** A straight forward comment and an example:
 *
 *       import { foo } from &quot;deno&quot;;
 *       foo(&quot;bar&quot;);
 */
</code></pre>
<p>既然代码示例已经是一个注释了，它就不应再包含其他注释。如果它需要进一步的注释，那意味着它不是一个很好的示例。</p>
<h3><a class="header" href="#每个模块都应该附带一个测试模块" id="每个模块都应该附带一个测试模块">每个模块都应该附带一个测试模块</a></h3>
<p>每个带有公共功能 <code>foo.ts</code> 的模块都应该附带一个测试模块 <code>foo_test.ts</code>。由于 <code>cli/js</code> 模块的上下文不同，它的测试应该放在 <code>cli/js/tests</code> 中，或者它应只是测试模块的同级模块。</p>
<h3><a class="header" href="#单元测试应是明确的" id="单元测试应是明确的">单元测试应是明确的</a></h3>
<p>为了更好地理解测试，函数应该在测试命令中按照提示正确命名，如:</p>
<pre><code>test myTestFunction ... ok
</code></pre>
<p>测试示例:</p>
<pre><code class="language-ts">import { assertEquals } from &quot;https://deno.land/std@v0.11/testing/asserts.ts&quot;;
import { foo } from &quot;./mod.ts&quot;;

Deno.test(&quot;myTestFunction&quot; function() {
  assertEquals(foo(), { bar: &quot;bar&quot; });
});
</code></pre>
<h2><a class="header" href="#顶级函数不应使用箭头语法" id="顶级函数不应使用箭头语法">顶级函数不应使用箭头语法</a></h2>
<p>顶级函数应使用 <code>function</code> 关键字。箭头语法应限于闭包。</p>
<p>错误示例：</p>
<pre><code class="language-ts">export const foo = (): string =&gt; {
  return &quot;bar&quot;;
};
</code></pre>
<p>正确示例：</p>
<pre><code class="language-ts">export function foo(): string {
  return &quot;bar&quot;;
}
</code></pre>
<h3><a class="header" href="#std" id="std"><code>std</code></a></h3>
<h4><a class="header" href="#不要依赖外部代码" id="不要依赖外部代码">不要依赖外部代码</a></h4>
<p><code>https://deno.land/std/</code> 旨在成为所有 Deno 程序可以依赖的基础功能。我们希望向用户保证，此代码不包含任何可能未经审核的第三方代码。</p>
<h4><a class="header" href="#文档以及维护浏览器兼容性" id="文档以及维护浏览器兼容性">文档以及维护浏览器兼容性</a></h4>
<p>如果一个模块兼容浏览器，在模块顶部的 JSDoc 中包含以下声明：</p>
<pre><code class="language-ts">/** This module is browser compatible. */
</code></pre>
<p>为该模块维护浏览器兼容性，在代码和测试中都不要使用 <code>Deno</code> 命名空间，确保任何新的依赖都兼容浏览器。</p>
<h2><a class="header" href="#内部细节" id="内部细节">内部细节</a></h2>
<h3><a class="header" href="#deno-和-linux-类比" id="deno-和-linux-类比">Deno 和 Linux 类比</a></h3>
<table><thead><tr><th align="right"><strong>Linux</strong></th><th align="left"><strong>Deno</strong></th></tr></thead><tbody>
<tr><td align="right">进程 (Processes)</td><td align="left">Web Workers</td></tr>
<tr><td align="right">系统调用 (Syscalls)</td><td align="left">Ops</td></tr>
<tr><td align="right">文件描述符 (fd)</td><td align="left"><a href="contributing/architecture.html#%E8%B5%84%E6%BA%90-resources">Resource ids (rid)</a></td></tr>
<tr><td align="right">调度器 (Scheduler)</td><td align="left">Tokio</td></tr>
<tr><td align="right">用户空间: libc++ / glib / boost</td><td align="left">https://deno.land/std/</td></tr>
<tr><td align="right">/proc/$$/stat</td><td align="left"><a href="contributing/architecture.html#%E6%8C%87%E6%A0%87-metrics">Deno.metrics()</a></td></tr>
<tr><td align="right">手册页 (man pages)</td><td align="left">deno types</td></tr>
</tbody></table>
<h4><a class="header" href="#资源-resources" id="资源-resources">资源 (Resources)</a></h4>
<p>资源（Resources)，又称 <code>rid</code>，是 Deno 版本的文件描述符。它们是一些整数数值，用来指代打开的文件、套接字 (sockets) 和其他概念。基于 <code>rid</code>，Deno 能够查询系统中有多少个打开的资源，这在测试时很有用。</p>
<pre><code class="language-ts">console.log(Deno.resources());
// { 0: &quot;stdin&quot;, 1: &quot;stdout&quot;, 2: &quot;stderr&quot; }
Deno.close(0);
console.log(Deno.resources());
// { 1: &quot;stdout&quot;, 2: &quot;stderr&quot; }
</code></pre>
<h4><a class="header" href="#指标-metrics" id="指标-metrics">指标 (Metrics)</a></h4>
<p>指标 (Metrics) 是 Deno 用于各种统计数据的内部计数器。</p>
<pre><code class="language-shell">&gt; console.table(Deno.metrics())
┌──────────────────┬────────┐
│     (index)      │ Values │
├──────────────────┼────────┤
│  opsDispatched   │   9    │
│   opsCompleted   │   9    │
│ bytesSentControl │  504   │
│  bytesSentData   │   0    │
│  bytesReceived   │  856   │
└──────────────────┴────────┘
</code></pre>
<h3><a class="header" href="#架构示意图" id="架构示意图">架构示意图</a></h3>
<p><img src="contributing/schematic_v0.2.png" alt="架构示意图" /></p>
<h1><a class="header" href="#示例" id="示例">示例</a></h1>
<p>在本章节，您可以找到一些示例程序，用来学习 Deno。</p>
<h2><a class="header" href="#unix-cat" id="unix-cat">Unix cat</a></h2>
<p>在这个程序中，每个命令行参数都是一个文件名，参数对应的文件将被依次打开，打印到标准输出流。</p>
<pre><code class="language-ts">const filenames = Deno.args;
for (const filename of filenames) {
  const file = await Deno.open(filename);
  await Deno.copy(file, Deno.stdout);
  file.close();
}
</code></pre>
<p>除了内核到用户空间再到内核的必要拷贝，这里的 <code>copy()</code> 函数不会产生额外的昂贵操作，从文件中读到的数据会原样写入标准输出流。这反映了 Deno I/O 流的通用设计目标。</p>
<p>尝试一下：</p>
<pre><code class="language-shell">deno run --allow-read https://deno.land/std/examples/cat.ts /etc/passwd
</code></pre>
<h2><a class="header" href="#文件服务器" id="文件服务器">文件服务器</a></h2>
<p>这个示例将会启动一个本地目录的 HTTP 服务器。</p>
<p>安装</p>
<pre><code class="language-shell">deno install --allow-net --allow-read https://deno.land/std/http/file_server.ts
</code></pre>
<p>运行</p>
<pre><code class="language-shell">$ file_server .
Downloading https://deno.land/std/http/file_server.ts...
[...]
HTTP server listening on http://0.0.0.0:4500/
</code></pre>
<p>如果想要升级到最新版本：</p>
<pre><code class="language-shell">file_server --reload
</code></pre>
<h2><a class="header" href="#tcp-echo" id="tcp-echo">TCP echo</a></h2>
<p>这个示例是一个 TCP echo 服务，接收 8080 端口的连接，把接收到的任何数据返回给客户端。</p>
<pre><code class="language-ts">const hostname = &quot;0.0.0.0&quot;;
const port = 8080;
const listener = Deno.listen({ hostname, port });
console.log(`Listening on ${hostname}:${port}`);
for await (const conn of listener) {
  Deno.copy(conn, conn);
}
</code></pre>
<p>当这个程序启动时，它会抛出一个没有网络权限的错误。</p>
<pre><code class="language-shell">$ deno run https://deno.land/std/examples/echo_server.ts
error: Uncaught PermissionDenied: network access to &quot;0.0.0.0:8080&quot;, run again with the --allow-net flag
► $deno$/dispatch_json.ts:40:11
    at DenoError ($deno$/errors.ts:20:5)
    ...
</code></pre>
<p>为了安全，Deno 不允许程序访问网络，除非显式赋予权限。使用一个命令行选项来允许程序访问网络：</p>
<pre><code class="language-shell">deno run --allow-net https://deno.land/std/examples/echo_server.ts
</code></pre>
<p>尝试用 netcat 向它发送数据。</p>
<pre><code class="language-shell">$ nc localhost 8080
hello world
hello world
</code></pre>
<p>像示例 <code>cat.ts</code> 一样，<code>copy()</code> 函数不会产生不必要的内存拷贝。它从内核接收数据包，然后发送回去，就这么简单。</p>
<h2><a class="header" href="#运行子进程" id="运行子进程">运行子进程</a></h2>
<p><a href="https://doc.deno.land/https/github.com/denoland/deno/releases/latest/download/lib.deno.d.ts#Deno.run">API 参考手册</a></p>
<p>示例：</p>
<pre><code class="language-ts">// 创建子进程
const p = Deno.run({
  cmd: [&quot;echo&quot;, &quot;hello&quot;],
});

// 等待完成
await p.status();
</code></pre>
<p>运行</p>
<pre><code class="language-shell">$ deno run --allow-run ./subprocess_simple.ts
hello
</code></pre>
<p><code>window.onload</code> 被赋值为一个函数，它将会在主脚本加载后被调用，和浏览器的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload">onload</a> 一样，可以用于主入口点。</p>
<p>默认情况下，当您调用 <code>Deno.run()</code> 时，子进程将继承父进程的标准流。如果您想要和子进程通信，可以使用 <code>&quot;piped&quot;</code> 选项。</p>
<pre><code class="language-ts">const fileNames = Deno.args;

const p = Deno.run({
  cmd: [
    &quot;deno&quot;,
    &quot;run&quot;,
    &quot;--allow-read&quot;,
    &quot;https://deno.land/std/examples/cat.ts&quot;,
    ...fileNames,
  ],
  stdout: &quot;piped&quot;,
  stderr: &quot;piped&quot;,
});

const { code } = await p.status();

if (code === 0) {
  const rawOutput = await p.output();
  await Deno.stdout.write(rawOutput);
} else {
  const rawError = await p.stderrOutput();
  const errorString = new TextDecoder().decode(rawError);
  console.log(errorString);
}

Deno.exit(code);
</code></pre>
<p>运行</p>
<pre><code class="language-shell">$ deno run --allow-run ./subprocess.ts &lt;somefile&gt;
[file content]

$ deno run --allow-run ./subprocess.ts non_existent_file.md

Uncaught NotFound: No such file or directory (os error 2)
    at DenoError (deno/js/errors.ts:22:5)
    at maybeError (deno/js/errors.ts:41:12)
    at handleAsyncMsgFromRust (deno/js/dispatch.ts:27:17)
</code></pre>
<h2><a class="header" href="#检查与放弃权限" id="检查与放弃权限">检查与放弃权限</a></h2>
<blockquote>
<p>这个程序使用了不稳定的 Deno 特性。更多信息请查阅
<a href="examples/../runtime/stability.html">稳定性</a></p>
</blockquote>
<p>有时一个程序会放弃之前获得的权限，在此之后，需要该权限的操作将失败。</p>
<pre><code class="language-ts">// 查找一个权限
const status = await Deno.permissions.query({ name: &quot;write&quot; });
if (status.state !== &quot;granted&quot;) {
  throw new Error(&quot;need write permission&quot;);
}

const log = await Deno.open(&quot;request.log&quot;, { write: true, append: true });

// 放弃一些权限
await Deno.permissions.revoke({ name: &quot;read&quot; });
await Deno.permissions.revoke({ name: &quot;write&quot; });

// 使用日志文件
const encoder = new TextEncoder();
await log.write(encoder.encode(&quot;hello\n&quot;));

// 这将会失败
await Deno.remove(&quot;request.log&quot;);
</code></pre>
<h2><a class="header" href="#处理系统信号" id="处理系统信号">处理系统信号</a></h2>
<blockquote>
<p>这个程序使用了不稳定的 Deno 特性。更多信息请查阅
<a href="examples/../runtime/stability.html">稳定性</a></p>
</blockquote>
<p><a href="https://doc.deno.land/https/raw.githubusercontent.com/denoland/deno/master/cli/dts/lib.deno.unstable.d.ts#Deno.signal">API 参考手册</a></p>
<p>您可以使用 <code>Deno.signal()</code> 函数来处理系统信号。</p>
<pre><code class="language-ts">for await (const _ of Deno.signal(Deno.Signal.SIGINT)) {
  console.log(&quot;interrupted!&quot;);
}
</code></pre>
<p><code>Deno.signal()</code> 也是一个 promise。</p>
<pre><code class="language-ts">await Deno.signal(Deno.Signal.SIGINT);
console.log(&quot;interrupted!&quot;);
</code></pre>
<p>如果您想要停止监控信号，可以使用信号对象的 <code>dispose()</code> 方法。</p>
<pre><code class="language-ts">const sig = Deno.signal(Deno.Signal.SIGINT);
setTimeout(() =&gt; {
  sig.dispose();
}, 5000);

for await (const _ of sig) {
  console.log(&quot;interrupted&quot;);
}
</code></pre>
<p>以上 for-await 循环将在 sig.dispose() 被调用时退出，运行时间为 5 秒。</p>
<h3><a class="header" href="#文件系统事件" id="文件系统事件">文件系统事件</a></h3>
<p>轮询文件系统事件：</p>
<pre><code class="language-ts">const watcher = Deno.watchFs(&quot;/&quot;);
for await (const event of watcher) {
  console.log(&quot;&gt;&gt;&gt;&gt; event&quot;, event);
  // { kind: &quot;create&quot;, paths: [ &quot;/foo.txt&quot; ] }
}
</code></pre>
<p>请注意，事件的确切顺序可能因操作系统而异。</p>
<p>此功能根据平台使用不同的系统调用：</p>
<ul>
<li>Linux: inotify</li>
<li>macOS: FSEvents</li>
<li>Windows: ReadDirectoryChangesW</li>
</ul>
<h2><a class="header" href="#测试当前文件是否为主程序" id="测试当前文件是否为主程序">测试当前文件是否为主程序</a></h2>
<p>当前脚本作为主程序的标志是 <code>import.meta.main</code>。</p>
<pre><code class="language-ts">if (import.meta.main) {
  console.log(&quot;main&quot;);
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
